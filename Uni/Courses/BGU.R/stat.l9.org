# -*- mode: Org; org-download-image-dir: "/home/zeltak/org/attach/bgu/courses/BGU.R/images"; org-download-heading-lvl: nil; -*-
#+Title:שיטות כמותיות למתקדמים
#+Author: ד"ר איתי קלוג 
#+Email: ikloog@bgu.ac.il
#+REVEAL_TITLE_SLIDE_BACKGROUND: /home/zeltak/org/attach/bgu/courses/BGU.R/images/stat_large.jpg

#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:nil reveal_control:t
#+OPTIONS: reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:nil
# #+REVEAL: split
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: linear
#+REVEAL_SPEED: default
#+REVEAL_THEME: white
#+REVEAL_HLEVEL: 2
#+REVEAL_HEAD_PREAMBLE: <meta name="description" content="Org-Reveal Introduction.">
#+REVEAL_POSTAMBLE: <p> Created by itai Kloog. </p>
# REVEAL_PLUGINS: (highlight markdown notes)
#+REVEAL_SLIDE_NUMBER: t
#+OPTIONS: ^:nil
#+EXCLUDE_TAGS: noexport
#+TAGS: noexport(n)
#+REVEAL_EXTRA_CSS: /home/zeltak/org/files/Uni/Courses/css/left.aligned.css


* Week 9
** dplyr advanced
*** Summarise values with summarise()
summarise()x collapses a data frame to a single row (this is exactly equivalent to 
plyr::summarise()):

in other words summarise = Reduce variables to values

Primarily useful with data that has been grouped by one or more variables

group_by creates the groups that will be operated on
#+REVEAL: split 

#+BEGIN_SRC R :session Rorg  :results none
summarise(flights,
  delay = mean(dep_delay, na.rm = TRUE))
#> Source: local data frame [1 x 1]
#> 
#>      delay
#>      (dbl)
#> 1 12.63907
#+END_SRC
select from DF 'flights'

then group by summary variable 'Dest'

then run the process creating a mean of 'ArrDelay' by 'Dest' into a variable called avg_delay

*lets try it on your computer!*
#+REVEAL: split 
aggregate XY by station

#+BEGIN_SRC R
#aggregate station xy
stnxy<-pm25.m1.c %>%
  group_by(stn) %>%
  dplyr::summarise(x = mean(x_stn_ITM, na.rm=TRUE),y = mean(y_stn_ITM, na.rm=TRUE) )
#+END_SRC
#+REVEAL: split 
*count number of obsv per station*

#+BEGIN_SRC R
tst<-met2007 %>%
    group_by(stn) %>%
    summarise(data = n())
#+END_SRC
#+REVEAL: split 
*summary by 2 grouped variables*

#+BEGIN_SRC R
flights %>%
  group_by(Dest,Month) %>%
  summarise(avg_delay = mean(ArrDelay, na.rm=TRUE))
#+END_SRC
*** Chaining
Usual way to perform multiple operations in one line is by nesting

we can write commands in a natural order by using the %>% infix operator (which can be pronounced as “then”)

Chaining increases readability significantly when there are many commands

Operator is automatically imported from the magrittr package

Can be used to replace nesting in R commands outside of dplyr
#+REVEAL: split 
 #+BEGIN_SRC R
 # chaining method
 flights %>%
     select(UniqueCarrier, DepDelay) %>%y
     filter(DepDelay >60)
 #+END_SRC
 this will select the DF 'flight'
 then ( %>%) select columns
 then ( %>%) filter deepelay >60 

*** Randomly sample rows with sample_n() and sample_frac()
You can use 

*sample_n()* and *sample_frac()* 

to take a random sample of rows:

use sample_n() for a fixed number and sample_frac() for a fixed fraction.

Use replace = TRUE to perform a bootstrap sample. If needed, you can weight the sample with the weight argument.
#+REVEAL: split 
#+BEGIN_SRC R :session Rorg  :results none
sample_n(flights, 10)
#> Source: local data frame [10 x 16]
#> 
#>     year month   day dep_time dep_delay arr_time arr_delay carrier tailnum
#>    (int) (int) (int)    (int)     (dbl)    (int)     (dbl)   (chr)   (chr)
#> 1   2013     6    12     1428        -7     1733       -17      DL  N370NW
#> 2   2013     3    23      600        -7      955        23      UA  N510UA
#> 3   2013     3    29     1814        14     1920         3      B6  N238JB
#> 4   2013     2    25     1957       -10     2156       -10      EV  N19966
#> ..   ...   ...   ...      ...       ...      ...       ...     ...     ...
#> Variables not shown: flight (int), origin (chr), dest (chr), air_time
#>   (dbl), distance (dbl), hour (dbl), minute (dbl)
sample_frac(flights, 0.01)
#> Source: local data frame [3,368 x 16]
#> 
#>     year month   day dep_time dep_delay arr_time arr_delay carrier tailnum
#>    (int) (int) (int)    (int)     (dbl)    (int)     (dbl)   (chr)   (chr)
#> 1   2013     5     7     1156        -4     1321       -17      UA  N432UA
#> 2   2013     4    18     1543        -5     1755       -25      DL  N369NB
#> 3   2013     3    26     1408        -7     1623        -8      DL  N344NB
#> 4   2013     1    24     2001        66     2211        71      MQ  N526MQ
#> ..   ...   ...   ...      ...       ...      ...       ...     ...     ...
#> Variables not shown: flight (int), origin (chr), dest (chr), air_time
#>   (dbl), distance (dbl), hour (dbl), minute (dbl)
#+END_SRC

** join data (dplyr)
*** create 2 "superhero" DF's
#+BEGIN_SRC R :session Rorg  :results none
suppressPackageStartupMessages(library(dplyr))
library(readr)

superheroes <-"
    name, alignment, gender,         publisher
 Magneto,       bad,   male,            Marvel
   Storm,      good, female,            Marvel
Mystique,       bad, female,            Marvel
  Batman,      good,   male,                DC
   Joker,       bad,   male,                DC
Catwoman,       bad, female,                DC
 Hellboy,      good,   male, Dark Horse Comics
"
superheroes <- read_csv(superheroes, trim_ws = TRUE, skip = 1)

publishers <- "
  publisher, yr_founded
         DC,       1934
     Marvel,       1939
      Image,       1992
"
publishers <- read_csv(publishers, trim_ws = TRUE, skip = 1)
#+END_SRC
*** inner_join(superheroes, publishers)
inner_join(x, y): Return all rows from x where there are matching values in y, and all columns from x and y. 

If there are multiple matches between x and y, all combination of the matches are returned. This is a mutating join.

#+BEGIN_SRC R :session Rorg  :results none
(ijsp <- inner_join(superheroes, publishers))
## Joining by: "publisher"
## Source: local data frame [6 x 5]
## 
##       name alignment gender publisher yr_founded
##      (chr)     (chr)  (chr)     (chr)      (int)
## 1  Magneto       bad   male    Marvel       1939
## 2    Storm      good female    Marvel       1939
## 3 Mystique       bad female    Marvel       1939
## 4   Batman      good   male        DC       1934
## 5    Joker       bad   male        DC       1934
## 6 Catwoman       bad female        DC       1934
#+END_SRC
#+REVEAL: split 

#+DOWNLOADED: /tmp/screenshot.png @ 2015-12-20 12:54:36
#+attr_html: :width 800px
 [[~/org/attach/bgu/courses/BGU.R/images/screenshot_2015-12-20_12:54:36.png]]

\\
We lose Hellboy in the join because, although he appears in x = superheroes, his publisher Dark Horse Comics does not appear in y = publishers. The join result has all variables from x = superheroes plus yr_founded, from y.
*** semi_join(superheroes, publishers)
semi_join(x, y): Return all rows from x where there are matching values in y, keeping just columns from x. 

A semi join differs from an inner join because an inner join will return one row of x for each matching row of y, where a semi join will never duplicate rows of x. 

This is a filtering join.
#+REVEAL: split 
#+BEGIN_SRC R :session Rorg  :results none
(sjsp <- semi_join(superheroes, publishers))
## Joining by: "publisher"
## Source: local data frame [6 x 4]
## 
##       name alignment gender publisher
##      (chr)     (chr)  (chr)     (chr)
## 1   Batman      good   male        DC
## 2    Joker       bad   male        DC
## 3 Catwoman       bad female        DC
## 4  Magneto       bad   male    Marvel
## 5    Storm      good female    Marvel
## 6 Mystique       bad female    Marvel
#+END_SRC 
#+REVEAL: split 
We get a similar result as with inner_join() but the join result contains only the variables originally found in x = superheroes. But note the row order has changed.

#+DOWNLOADED: /tmp/screenshot.png @ 2015-12-20 12:55:12
#+attr_html: :width 800px
 [[~/org/attach/bgu/courses/BGU.R/images/screenshot_2015-12-20_12:55:12.png]]

*** left_join(superheroes, publishers)
left_join(x, y): Return all rows from x, and all columns from x and y. 

If there are multiple matches between x and y, all combination of the matches are returned. This is a mutating join.
#+BEGIN_SRC R :session Rorg  :results none
(ljsp <- left_join(superheroes, publishers))
## Joining by: "publisher"
## Source: local data frame [7 x 5]
## 
##       name alignment gender         publisher yr_founded
##      (chr)     (chr)  (chr)             (chr)      (int)
## 1  Magneto       bad   male            Marvel       1939
## 2    Storm      good female            Marvel       1939
## 3 Mystique       bad female            Marvel       1939
## 4   Batman      good   male                DC       1934
## 5    Joker       bad   male                DC       1934
## 6 Catwoman       bad female                DC       1934
## 7  Hellboy      good   male Dark Horse Comics         NA
#+END_SRC
#+REVEAL: split 
We basically get x = superheroes back, but with the addition of variable yr_founded, which is unique to y = publishers. Hellboy, whose publisher does not appear in y = publishers, has an NA for yr_founded.

#+DOWNLOADED: /tmp/screenshot.png @ 2015-12-20 12:56:03
#+attr_html: :width 800px
 [[~/org/attach/bgu/courses/BGU.R/images/screenshot_2015-12-20_12:56:03.png]]
*** anti_join(superheroes, publishers)
anti_join(x, y): Return all rows from x where there are not matching values in y, keeping just columns from x. This is a filtering join.

#+BEGIN_SRC R :session Rorg  :results none
(ajsp <- anti_join(superheroes, publishers))

## Joining by: "publisher"
## Source: local data frame [1 x 4]
## 
##      name alignment gender         publisher
##     (chr)     (chr)  (chr)             (chr)
## 1 Hellboy      good   male Dark Horse Comics
#+END_SRC
#+REVEAL: split 

#+DOWNLOADED: /tmp/screenshot.png @ 2015-12-20 12:56:56
#+attr_html: :width 800px
 [[~/org/attach/bgu/courses/BGU.R/images/screenshot_2015-12-20_12:56:56.png]]
\\
We keep only Hellboy now (and do not get yr_founded).
*** full_join(superheroes, publishers)
full_join(x, y): Return all rows and all columns from both x and y. Where there are not matching values, returns NA for the one missing. This is a mutating join.
#+BEGIN_SRC R :session Rorg  :results none
(fjsp <- full_join(superheroes, publishers))
## Joining by: "publisher"
## Source: local data frame [8 x 5]
## 
##       name alignment gender         publisher yr_founded
##      (chr)     (chr)  (chr)             (chr)      (int)
## 1  Magneto       bad   male            Marvel       1939
## 2    Storm      good female            Marvel       1939
## 3 Mystique       bad female            Marvel       1939
## 4   Batman      good   male                DC       1934
## 5    Joker       bad   male                DC       1934
## 6 Catwoman       bad female                DC       1934
## 7  Hellboy      good   male Dark Horse Comics         NA
## 8       NA        NA     NA             Image       1992

#+END_SRC
#+REVEAL: split 
We get all rows of x = superheroes plus a new row from y = publishers, containing the publisher Image. We get all variables from x = superheroes AND all variables from y = publishers. Any row that derives solely from one table or the other carries NAs in the variables found only in the other table.

#+DOWNLOADED: /tmp/screenshot.png @ 2015-12-20 12:58:46
#+attr_html: :width 800px
 [[~/org/attach/bgu/courses/BGU.R/images/screenshot_2015-12-20_12:58:46.png]]
** ggplot2
*** Introduction
:PROPERTIES:
:CUSTOM_ID: slide_1
:END:

ggplot2 is a powerful and a flexible R package, implemented by Hadley Wickham, for producing elegant graphics.

#+ATTR_HTML: :style text-aligns:center
http://ggplot2.org/


#+DOWNLOADED: /tmp/screenshot.png @ 2015a-12-03 16:21:38
#+attr_html: :width 500px 
 [[~/org/attach/bgu/courses/BGU.R/images/screenshot_2015-12-03_16:21:38.png]]



#+REVEAL: split 
The concept behind ggplot2 divides plot into three different fundamental parts:

*Plot = data + Aesthetics + Geometry.*

The principal components of every plot can be defined as follow:

data is a data frame

Aesthetics is used to indicate x and y variables. It can also be used to control the color, the size or the shape of points, the height of bars, etc…..

Geometry defines the type of graphics (histogram, box plot, line plot, density plot, dot plot, ….)
#+REVEAL: split 
There are two major functions in ggplot2 package: qplot() and ggplot() functions.

qplot() stands for quick plot, which can be used to produce easily simple plots.

ggplot() function is more flexible and robust than qplot for building a plot piece by piece.

#+REVEAL: split 

Install and load ggplot2 package

#+BEGIN_SRC R :session Rorg  :results none
# Installation
install.packages('ggplot2')

# Loading
library(ggplot2)
#+END_SRC
#+REVEAL: split 
Data format and preparation

The data should be a data.frame (columns are variables and rows are observations).

The data set mtcars is used in the examples below:

#+BEGIN_SRC R :session Rorg  :results none
# Load the data
data(mtcars)
df <- mtcars[, c("mpg", "cyl", "wt")]
head(df)
##                    mpg cyl    wt
## Mazda RX4         21.0   6 2.620
## Mazda RX4 Wag     21.0   6 2.875
## Datsun 710        22.8   4 2.320
## Hornet 4 Drive    21.4   6 3.215
## Hornet Sportabout 18.7   8 3.440
## Valiant           18.1   6 3.460

#+END_SRC
#+REVEAL: split 


* Sources
http://www.sthda.com/english/wiki/be-awesome-in-ggplot2-a-practical-guide-to-be-highly-effective-r-software-and-data-visualization?utm_content=bufferf4c6a&utm_medium=social&utm_source=plus.google.com&utm_campaign=buffer

http://www.gardenersown.co.uk/education/lectures/r/anova.htm#anova_models
