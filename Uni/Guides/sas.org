#+TITLE: sas

* Help/fixes
** Help in SAS

** SAS support online

** Errors

** keyboard shortcuts

run code block > F3
 clear log screen > Ctrl-e
stop/kill/halt SAS proccess  ~ctrl-Break~

** SAS program commands (clear etc)

/*clear editor*/*
 DM 'ODSRESULTS' CLEAR EDITOR; ODS HTML CLOSE;
 */*clear log*/*
 DM 'CLEAR LOG; CLEAR OUTPUT; PGM OFF' LISTING;
 /*clean all library */
 proc datasets lib=work kill; run;
 *suppress log window:
*
 ods listing close;*to suppress the output printing;
 options nonotes nosource nosource2 ; *suppresses LOG WINDOW printing;
  
 You can reinstate the function of these options with the *'No'*removed
from each
 option:
 OPTIONS source notes;

** Unable to open SASUSER.REGSTRY. WORK.REGSTRY

When you invoke SAS 9.1, the following warning and notes might appear:
 NOTE: Unable to open SASUSER.REGSTRY. WORK.REGSTRY will be opened
 instead.
 NOTE: All registry changes will be lost at the end of the session.
 WARNING: Unable to copy SASUSER registry to WORK registry. Because of
 this, you will not see registry customizations during this session.
 NOTE: Unable to open SASUSER.PROFILE. WORK.PROFILE will be opened
 instead.
 NOTE: All profile changes will be lost at the end of the session.
 NOTE: This SAS session is using a registry in WORK. All changes will
 be lost at the end of this session.
 This message can be caused by corrupted profiles. To correct this,
perform the following steps:
     Close SAS.
     Open Windows Explorer. There are several ways to do this. Here are
a few different ways, dependent on your Windows operating system:
         Select Start ► Run. Then type explorer in the Open text box and
click OK.
         Click Start and type explorer in the blank search text box.
         Right-click Start and select Explore.
         Right-click Start and select Open Windows Explorer.
     In the Windows XP environment, go to C:\Documents and
Settings\your--user--id\My Documents\My SAS Files\9.1.
     In the Windows Vista environment, go to C:\Users\your--user--id\My
Documents\My SAS Files\9.1.
     Locate the file profile2.sas7bcat and rename it as profile2.old.
     Locate profile.sas7bcat and rename this file as profile.old.
     Locate regstry.sas7bitm and rename this file as regstry.old.
     Restart SAS.

** formatting error

 libname zn2 'f:\sast\zinc\' ;
 OPTIONS nofmterr;
* SAS basic commands
** `How do I set up a different WORK directory for SAS`

http://www.ats.ucla.edu/stat/sas/icu/custom_win.htm

Sometimes, the default location for SAS temporary WORK directory may not be large enough. You can change the location for WORK directory when you start up SAS.

The easiest way to do it may be to modify the parameters for sas.exe. Here is how to do it.

Step 1. Right click on the icon of SAS and choose Properties. This will bring up a window called SAS Properties shown below.

Step 2. Choose the Shortcut Menu.

The Target field tells us where the sas.exe is located and what parameters it takes. In this example, it looks like:

"C:\Program Files\SAS Institute\SAS\V8\sas.exe" -CONFIG "C:\Program Files\SAS Institute\SAS\V8\SASV8.CFG"

This tells us that the executable sas.exe is located in the folder C:\Program Files\SAS Institute\SAS\V8\ and it uses the default configuration file SASV8.CFG located in the folder  C:\Program Files\SAS Institute\SAS\V8.

Step 3. Let's say that we want to change the WORK directory to D:\temp. In the Target field, we can add  "-work "D:\temp" at the end. Then the target line becomes 

"C:\Program Files\SAS Institute\SAS\V8\sas.exe" -CONFIG "C:\Program Files\SAS Institute\SAS\V8\SASV8.CFG" -work "D:\temp"

Click on the OK button.

That's all to it. Now after you fire up SAS, you can double check if the WORK directory has been set up to the location you want. For example, you can do:

#+BEGIN_EXAMPLE
proc options option=work;
run;

(From Log Window:)
3    proc options option=work;
4    run;

    SAS (r) Proprietary Software Release 8.2  TS2M0

 WORK=D:\temp\_TD3260
                   Location for WORK SAS data library
#+END_EXAMPLE

You may notice that SAS actually created a subfolder in the directory that we have specified. This is because SAS allows multiple sessions (that is to say that you can fire up SAS multiple times) and each session will require its own temporary work space. SAS will create a unique temporary WORK directory for each of the multiple sessions in D:\temp.  


** procs
*** proc content (show dataset content)

proc contentst show the contents of a file and all variable attributes
run:
 proc contents data=h.cases;
 run;
 [[sas_files/img/Pasted.jpg]]

*** proc plot

proc plot;
 plot VAR1*VAR2;
 run;

*** proc corr

proc corr data = aod.data;
 var read write math science female;
 run;

*** proc reg

proc reg data = pmstat\_2001\_v6;
 model mfvalue = pm\_mod3 / clb;
 run;
 quit;

*** proc gplot

 proc gplot data=pmstat\_2001\_v6;
    plot mfvalue * pm\_mod3;
 run;

*** proc glm

to get confidence levels add *clparam*to the model section
 model x=y /clparam
** stop/pause SAS
*** keybind to stop SAS
use:
?C-Pause?
** Operators
*** table of operators

[[./sas_files/img/Image_NZs2JRrvOViqWanSqN96cA_0001.png]]
 [[./sas_files/img/Image_NZs2JRrvOViqWanSqN96cA_0002.png]]

*** not equal

the not equal sign is ne:
 IE:
 if c ne 2000 then delete;

*** if then

you can use this syntax:
 data DATA;
 set DATAORIG;
  if prgtype = "academic" then prog = 1;
 if prgtype = "general" then prog = 2;
 if prgtype = "vocational" then prog = 3;
 run;

*** select cahracter variables

use the '' (qoutes) to reffer to character variables
 IE:
 data pm3x;
 set pm3 ;
 if dataset = 'IMPFSPED' then delete;
 run;

*** character data

**** select missing character data

use empty qoutes:
 " "
 to reffer to missing character data
 IE:
 if sitecode= "" then sitecode=.;

*** put in a range of variables

use the '*--*' sign
 IE:

random VAR1--

VAR20

;
 *example:*
 random zelev.x--zasource / sub = zid type=toep(1) s;

** clear data
*** clear output and log windows

use this command:
 dm "out;clear;log;clear;";
 or:
 DM 'ODSRESULTS' CLEAR EDITOR; ODS HTML CLOSE;
 DM 'CLEAR LOG; CLEAR OUTPUT; PGM OFF' LISTING;

*** clear work directory

use this command:
 proc datasets lib=work kill; run;

*** How do I clear a graph window in SAS

If you run the following code, it will clear the text from a graph
window. Note that the graph will remain after you run the code, but will
disappear when you issue your next proc gplot
 proc greplay igout=work.gseg nofs;
 delete \_all\_;
 run;
 quit;
 Pasted from
<[[http://faq.rutgers.edu/?q=node/13][http://faq.rutgers.edu/?q=node/13]]>

*** clear log/output

*/*clear editor*/*
 DM 'ODSRESULTS' CLEAR EDITOR; ODS HTML CLOSE;
 */*clear log*/*
 DM 'CLEAR LOG; CLEAR OUTPUT; PGM OFF' LISTING;
 /*clean all library */
 proc datasets lib=work kill; run;
 *suppress log window:
*
 options nonotes nosource nosource2 NOMLOGIC NOMPRINT NOMRECALL
NOSYMBOLGEN errors=0; *suppresses LOG WINDOW printing
 You can reinstate the function of these options with the *'No'*removed
from each
 option:
 OPTIONS source notes;
 *suppress output window:*
 ods listing close;*to suppress the output printing;

*** clear specific datasets

issue this:
 *
 proc datasets lib=work; delete DATASET1 DATASET2 DATASET3 ; run;;*

*** supress log output completly
-Solution 1-
 Suppress the listing of the entire log, or part of the log, for later
SAS program submissions. Do not suppress all the log messages until you
have successfully executed the program without an error.
 Add the following OPTIONS statement to the top of your SAS program to
suppress printing to the log:
 options nonotes nosource nosource2 errors=0;
 If you want to change the options back to the default and start
printing to the log again, submit the following OPTIONS statement:
 options notes source source2 errors=20;
 The SAS system options are as follows:
 Errors - specifies the maximum number of observations for which data
 error messages are printed.
 Notes - controls whether messages beginning with NOTE are written to
 the SAS log. Because notes are required for debugging, use
 this option until your program is error free.
 Source - controls whether SAS program source statements are written
 to the SAS log.
 Source2 - controls whether secondary source statements and notes about
 secondary source statements from files included by %INCLUDE
 statements are written to the SAS log.
-Solution 2-
 Redirect the contents of the Log window to a file instead of the Log window. To accomplish this, add the following code to the top of your
program:

proc printto log="c:\directory-name\filename.log"; run;

Note: Use the drive letter, subdirectory, and filename that correspond to your installation in the command above. The subdirectory must already exist on your machine. Or, if you don't want to save the contents of the log at all, use the Microsoft Windows NUL device:

proc printto log="nul:"; run;

then, at the end of your program, add the following code to redirect
the output back to the Log window:

proc printto; run;


-Solution 3-
 In SAS® 9.2, DMSLOGSIZE is a new SAS system option that enables you to
designate the maximum number of rows that the Log window can display.
The default is 99,999 rows. The range is 500 to 999,999 rows. To change
the option, add the following code to the top of your sasv9.cfg file,
starting in column one:
 -dmslogsize 150000
 The number 150000 shown above is just an example. You can change this
value to the number of rows that are required for your installation.
Save the sasv9.cfg file and restart SAS.
 In SAS 9.1, if you attempt to use this option, the scroll size is not
extended, therefore, you could receive an error when you scroll in the
output window. However, it does allow the program to complete without
the log-window-full message.
 Note: A similar option, DMSOUTSIZE, is available for the SAS Output
window. See SAS Note 12452 "The message"Output window full" appears in
Microsoft Windows operating environments" for details. A similar option
is not available for the Program Editor window. Use the Enhanced Editor
window instead.

** formating

*** The format was not found or could not be loaded.

issue this:
 OPTIONS nofmterr;*
 Pasted from
<[[http://www.ats.ucla.edu/stat/sas/faq/nofmterr.htm][http://www.ats.ucla.edu/stat/sas/faq/nofmterr.htm]]>*
* Data Input
** Import
*** import csv files
*** Import from Excel
*** import from dbf

*** import from Spss

*** importing from SAS

*** import txt file
**** SAS intro

[[./sas_files/attach/59498.pdf][Attachment #01 (59498.pdf)]]
 simple example:
 proc import datafile="PATH\TO\TXT.txt"
  dbms=dlm out=OUTFILE replace;
  delimiter=",";
  getnames=yes;
 guessingrows=500;
 run;
 *note: see ATTACHMENT for much more detail*
 [[./sas_files/img/Image_f7rzdZzj79yEHSvaBc8fBw_0001.png]]

The ID variable is read in as a character variable using the
*$6.*informat in line ...
 The *$/w./*informat tells SAS that the variable is character with a
length */w/*. The *$/w.
/*informat will also left-justify the variable (leading blanks
eliminated). Later in this
 section we will compare results using the *$CHAR/w./*informat, which
retains leading
 blanks.
 Line .. instructs SAS to read in the transaction date (Tran\_Date)
using the date
 informat *MMDDYY/w/.*Since each date field occupies 10 spaces, the
/w./qualifier is
 set to 10.
 Line .. uses the numeric informat *8.2*. The */w.d/*informat provides
instruction to read
 the numeric data having a total width of 8 (8 columns) with two digits
to the right of
 the decimal point. SAS will insert a decimal point only if it does not
encounter a
 decimal point in the specified /w/columns. Therefore, we could have
coded the
 informat as *8.*or 8.2.
 [[./sas_files/img/Image_f7rzdZzj79yEHSvaBc8fBw_0002.png]]

*
*

**** zeltak example
 my example:
 data WORK.tmp&filen.;
  INFILE
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.1.NE\_PM\_MODELS\3.1.1.1.Raw\_data\MODIS\_AOD\&filename."
  delimiter='09'x MISSOVER DSD lrecl=32767;
 *INPUT*
 @1 Year BEST4.
 @5 Month BEST3.
 @8 Day BEST3.
 @11 Longitude  COMMA6.
 @22 Latitude  COMMA6.
 @33 AOD  COMMA5.
 @38 Unknown\_Values BEST10. ;
 RUN
 the @xx means the length of the column. for example the above code
refers to this text file:
 2000 03 01 -73.250 41.250 0.420
 2000 03 01 -73.450 41.150 0.387
 2000 03 01 -73.450 41.350 0.414
 2000 03 01 -73.550 40.750 0.680
 so the @1 is the start of the 'year' column and the @5 is the start of
the month column( *the cursor spot before the actual number start*).
 *Note: Spaces do count as a character space
 (1)*2000 *(5)*03 01 -73.550 41.250 0.395

*** make sure sas dosent treat character variables as missing

if you have a mixed variables (numeric+string) sas will make all
character variables missing add the gussingrows option to make sure it reaches some character rows
to show sas its a mixed variable:

#+BEGIN_SRC sas
PROC IMPORT OUT= met2003
 DATAFILE="f:\Uni\Projects\P020\_Temprature\_NE\_MIA\3.Work\2.Gather\_data\FN012\_met\_all\met2003all.csv"
 DBMS=CSV REPLACE;
 GETNAMES=YES;
 GUESSINGROWS=100000;
 DATAROW=2;
 RUN;
#+END_SRC

** Export
*** Export csv
#+BEGIN_SRC sas
/*export to r*/
PROC EXPORT DATA= WORK.times7
            OUTFILE= "f:\Uni\Projects\P042_Medicare_THROM\3.1.10.4.Work\3.Analysis\AN002_timeseries\all_0008.csv" 
            DBMS=CSV REPLACE;
     PUTNAMES=YES;
RUN;
#+END_SRC
*** export dbf

*** Export Tab Delimited

*** export part of output to a table

*** export Excel

*** export Spss

*** export SAS

*** output fixed and random results to a db

To output the results (solution) of a regression into a file/DB use the
ODS system.
 For example:
 ods output solutionf=year.solution\_fixed
solutionr=year.solution\_random;
 where:
 solutionf=is the fixed result file
 solutionr=is the random result file
 year.solution\_fixed= library.filename

*** export to R

libname rd xport "\PATH\TO\*FILENAME.xport*";
 proc copy in=*work* out=rd; select *SASFILE* ;run;
  
 *work-SAS library the file is in
 SASFILE-The actual file in SAS !!!!!!!!!NOTE-must be less then 6
characters-in not CONVERT the file name first IE:
**
 FILENAME.xport-file to be exported*

*** Redirect the contents of the Log window to a file instead of the Log window

Redirect the contents of the Log window to a file instead of the Log
window. To accomplish this, add the following code to the top of your
program:
 proc printto log="c:\directory-name\filename.log"; run;
 Note: Use the drive letter, subdirectory, and filename that correspond
to your installation in the command above. The subdirectory must already
exist on your machine.
 Then, at the end of your program, add the following code to redirect
the output back to the Log window:
 proc printto; run;

** SAS Library
*** define SAS library

always start but defining the place of your data:
 libname t2005 'X:\2)PostDoc\Database\AOD\_NE\SAS\lib\final\Terra\2005\'
;
 t2005 is the name SAS will now use for the library location
 X:\2)PostDoc\... is where the actuall path to the library is
 then when you write code you can use t2005. (dot) and then filename to
show the file in the specfic dir. also you can copy files to a new one
to not ruin the old one for example:
 DATA t2005.all\_clean;
  SET t2005.all;
  RUN;
 t2005 means its in the folder stated in the above command
(X:\2)PostDoc\...)
 all is the current file uses
 all\_clean is the new file to be created

** pipe filenames to SAS
you can use the pipe command to pipe files to a list:
 filename DIRLIST pipe 'dir
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.1.Raw\_data\MODIS\_AOD\"
/s';
 you may need sometimes to use the /b switch
 filename DIRLIST pipe 'dir
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.1.NE\_PM\_MODELS\3.1.1.1.Raw\_data\MODIS\_AOD\"
/b';

* Data Management
** Creating new dataset/variables
*** create a new variable

in SAS to create a new vbariable:
 DATA NAME; SET NAME2; NEWVAR=XXXXX; run;
 NOTE: if you want the new variable to be character add the '' (IE 'XX')
to the variable needed
 example:
 data a2003\_001\_v2 ; set a2003\_001 ; jy='2003'; jul='001'; run;

*** create empty dataset

*** create class variables (class command)

the class command creates dummy variables that run in the regressions.
 for example to create a dummy variable for date we would use the
following command:
 class date\_;
 an example in a mixed model regression:
 proc mixed data=t2005.t2005all\_clean;
 class date\_;
 model mfvalue = aod pop\_den dist\_ocean contour traf\_den /solution;
 random intercept aod / subject=date\_ ;
 run;
 TE:
 here it the example it will create a dummy variable for each day

*** create Dummy variables

to create a dummy variable:
 DATA year.t2000all\_clean\_v2;
 SET year.t2000all\_clean;
 if dist\_ocean < 10 then dist\_ocean\_dumm =1;
 ELSE dist\_ocean\_dumm = 0;
 RUN;
 dist\_ocean-variable based on
 dist\_ocean\_dumm -new dummy variable

*** rearannge variables

to rearrange variables in SAS , the best way is to create a new dataset
and define the order you need.
 this is done with proc sql:

#+begin_src sas
proc sql;
  create table DATA2 as
  select VAR1,VAR2,VAR3
  from DATA1
quit;
#+end_src


%TIP:a ',' is needed between each variable%

*** create variables from means of other variables

Example:
 data stroke\_v2;
 set stroke;
 lag0=pmnew;
 lag0\_1=MEAN(pmnew,pm\_lag1);
 lag1\_2=MEAN(pm\_lag1, pm\_lag2);
 lag0\_2=MEAN(pmnew,pm\_lag1, pm\_lag2);
 run;

*** create a unique id for xy variables

create a unique id for xy variables:
 /*copy x and y coordinantes from numeric to character (text)
variables*/
 data mixpred2000\_s2 ;
 set mixpred2000 ;
 xnym=put(X,6.2);
 ynym=put(Y,6.2);
 run;
 data mixpred2000\_s2x ;
 set mixpred2000\_s2 ;
 xnymx = xnym*-100;
 ynymx = ynym*100;
 run;
 /*concentrate (compress) both x and y variables into one ID*/
 data mixpred2000\_s3;
 set mixpred2000\_s2x;
 uid=compress(xnymx||ynymx);
 run;
 /*convert if from text to numeric*/
 data mixpred2000\_s4;
 set mixpred2000\_s3;
 guid=input(uid, 8.);
 run;

*** create uniqe id for each case
To assign serial numbers to observations in a data set in SAS, create a variable using _N_, a system variable, which contains observation numbers from 1 through n. Consider the following example:

The id = _N_; copies observation numbers to the variable id.

#+begin_src sas
 DATA market_new;
  SET mydata_old;
      id = _N_;
  RUN;
#+end_src



 Pasted from
<[[http://www.tek-tips.com/viewthread.cfm?qid=1524147][http://www.tek-tips.com/viewthread.cfm?qid=1524147]]>

** Recode variables

*** recode with range

use something like this:

 if age <= *20* then aged=*1*;
 if *20* < age <=*29* then aged=*2*;
 if *29* < age <=*34* then aged=*3*;
 if *34* < age <=*39* then aged=*4*;
 if age > *39* then aged=*5*;;

 another example:
 data bw6;
 set bw5;
 if 0 < MOTHEREDUC < 8 then edu\_group=1;
 if 8 < MOTHEREDUC < 12 then edu\_group=2;
 if 12 < MOTHEREDUC < 15 then edu\_group=3;
 if MOTHEREDUC >15 then edu\_group=4;
 run;

*** macro to auto create dummy variables

[[./sas_files/attach/dummy_var_creator_original.sas][Attachment #02
(dummy\_var\_creator\_original.sas)]]
 [[./sas_files/attach/cnXX_macro_dummy_var_creator.sas][Attachment #03
(cnXX\_macro\_dummy\_var\_creator.sas)]]
 this example was taken from here

[[http://www.datavis.ca/sas/vcd/macros/dummy.sas][http://www.datavis.ca/sas/vcd/macros/dummy.sas]]
 for the complete script including very detailed explenation -> *(see
attachments)*
 these are the important bits:
 1)add the actual statement at the bottom of the code:
 %dummy (data = bw\_noces , var = MRN kess byob , out= bw\_noces\_dummy,
prefix=varname) ;

*** example with character varibles to numeric

**

data all3;
 set all2;
 if race = "1" then brace=*1*;
 if race = "2" then brace=*2*;
 if race in ("0","3","4","5","6") then brace = *3*;
 *run*;
 ;

*** if in example

**

data all3;
 set all2;
 if race = "1" then brace=*1*;
 if race = "2" then brace=*2*;
 if race in ("0","3","4","5","6") then brace = *3*;
 *run*;
 ;

** Missing Data

*** Testing for Missing Values

use proc means to detect missing cases
 proc means data=ran5\_t2000 nmiss;
 var pred;
 run;

** Deleting Data

*** Excluding with keep/drop

you can use either keep or drop to get rid of variables..use whatever is
shorter to type
 keep- specifies what variables to keep
 drop- specifies what variables to drop
 *NOTE: make sure you output to a new dataset
*
 IE:
 DATA auto2;
 set auto;
 keep make mpg price;
 RUN;
 The keep data step option can also control which variables are written
to the new file.
  DATA AUTO2 (keep = make mpg price);
 SET auto;
 RUN;
 Other examples:

------------------------------------------------------------------------------------------------------------------
 data year.t2004all\_clean\_v2;
 set year.t2004all\_clean;
 drop join\_count join\_cou\_1 dist\_ocean poc countyfips orig\_fid
Shape\_Leng traf\_den dist\_ocean ;
 run;

------------------------------------------------------------------------------------------------------------------
 or alternatively use the keep command if it easier:

------------------------------------------------------------------------------------------------------------------
 data mergif.TM2000\_s4;
 set mergif.TM2000\_s3;
 keep mfvalue date2 d m c x y aod P\_Ospace contour pmpred uid ;
 run;

------------------------------------------------------------------------------------------------------------------

*** Delete rows

*** delete duplicate cases

use the following code:
 proc sort data = DATASETNAME nodupkey out=DATAOUTPUTNAME;
 by date sitecode;
 run;
 *IE:*
 proc sort data = allpm0008 nodupkey out=noduplicate;
 by date sitecode;
 run;

*** FIRST. and LAST. (delete duplicates by first or last)

If you use a by statement along with a set statement in a data step then
SAS creates two automatic variables, FIRST.variable and LAST.variable,
where variable is thename of the by variable.
 example:
 proc sort data = met2001; by station date; run;
 data new; set met2001; by station date;
 if first.date;
 run;
 proc freq data=met2001;
 table station / list;
 run;
 this will arrange the data by station and date, and then only keep in
each day (date) the first object
 you can also do it for multi levels:
 proc sort data=lst2001k2; by station date dist;
 data lst2001k2; set lst2001k2; by station date dist;
 if first.date;
 run;
 here we sort it by station date and dist in order to be left with 1
value for each day in each station based on shortest distance.
 since the distance is sorted asecindg (the default) then by issues the
first.date command it will take the first date in the
*station-date-dist* sort and that would be the shortest distance one.

*** delete missing cases

 data merg.aodmc\_final\_v2;
 set merg.aodmc\_final;
 if VARIABLE =. then delete; ;
 run;

 example:



 data merg.aodmc\_final\_v2;
 set merg.aodmc\_final;
 if pm2.5 =. then delete; ;
 run;

** Sorting

*** using proc sort

proc sort data= DATA;
 by siteid;
 run;
 you can also sort by multiple variables:
 proc sort data= temp.Epasites;
 by siteid date;
 run;

** Merging Data
*** Adding Columns (merge)

The MERGE statement joins corresponding observations from two or more
SAS data sets into single observations in a new SAS data set.
 You can merge data sets with or without a BY statement. Without a BY
statement, MERGE performs one-to-one merging by joining the first
observation in one data set with the first observation in another, the
second observation in one data set with the second observation in
another, and so on. With a BY statement, MERGE performs match-merging by
joining observations from two or more sorted data sets, based on the
values of the common BY variables. The syntax for the MERGE statement
is:
 *Note: both data sets must be sorted by the key variables you sort
*
 MERGE datasets [(options)] ;
 [BY variables ;]
 where:
 datasets are two or more existing SAS data sets.
 [(options)] are data-set options, enclosed in parentheses.
 [BY variables ;] are the matching variables for the BY statement.
 Each data set must be sorted by these variables. SAS functions are
routines that return values computed from one or more arguments; they
are used to create new variables or modify existing ones. Functions are
used in statements that have the syntax:
 *Note: if using the keep/drop options make sure the by variable is
kept*
 *
 example:*
 proc sort data= temp.Epasites;
 by siteid;
 run;
 proc sort data= temp.Epa\_met;
 by siteid;
 run;
 data epadata;
 merge temp.Epa\_met (keep=siteid epa site) temp.Epasites (keep=siteid
LATITUDE LONGITUDE) ;
 by siteid;
 run;

*** The IN= variables (merge and keep from only 1 dataset)

*The IN= variables*
 What if you want to keep in the output data set of a merge only the
matches (only those observations to which both input data sets
contribute)? SAS will set up for you special temporary variables, called
the "IN=" variables, so that you can do this and more.
 *example dataset*
 Data set one Data set two
 ID A B ID C

 10 1 2 10 0
 20 3 4 30 1
 30 5 6 40 1
 *
 Here's what you have to do:*
 signal to SAS on the MERGE statement that you need the IN=
variables for the input data set(s)
 use the IN= variables in the data step appropriately
 So to keep only the matches in the match-merge above, ask for the IN=
variables and use them:
 data three;
 merge one (in=x) two(in=y); /* x & y are your choices of
names */
 by id; /* for the IN= variables for data */
 if x=1 and y=1; /* sets one and two respectively */
 run;
 *NOTE: its better to use a and b instead of x and y sometimes since
they may conflict with actual variables*
 Data set three will now consist of only the matches on ID:
 ID A B C
 10 1 2 0
 30 5 6 1
 Only the matches are kept in the output data set above because of the
way the IN= variables X and Y take on values in the PDV:
 *1 if the data set contributes to the observation
 0 if the data set does not contribute to the observation
*
 For the above example, you can picture the IN= variables X and Y taking
on values like this:

 ID A B C X Y
 10 1 2 0 1 1
 20 3 4 . 1 0
 30 5 6 1 1 1
 If you want to keep not only the matches, but also to keep track in
separate data sets of the non-matches, you can let the data step create
three data sets like this:
 data x1y1 /* x1y1, x1y0, x0y1 are your choices of data set names
*/
 x1y0
 x0y1;
 merge one(in= x) two(in= y);
 by id;
 if x = 1 and y = 1 then output x1y1; /* write all matches to
x1y1 */
 if x = 1 and y = 0 then output x1y0;
 if x = 0 and y = 1 then output x0y1;
 run;

*** complex mergege with multiple repeating  variables (guid and zipcodes)
this example shows how to prefrom a complex merge in SAS where you
have several zipcodes associated with one grid id (guid)

#+begin_src sas


PROC SQL;
create table nexpo.mergesql1 as
SELECT tall.guid, pmguid.zipcode, tall.date,
tall.glong, tall.glat, tall.fintemp
FROM work.pmguid LEFT JOIN nexpo.tall ON pmguid.guid = tall.guid;
quit;

#+end_src

where:
1.the 'create table' line is where the output file is created ('LIB.NAME'
format)
2.The 'select' line chooses which variables are kept from the 2
datasets joined (`tall` and `pmguid`) and the variables joined to
them (`glong`, `glat` etc). the format is 'NAME.VARNAME'.
3.the 'FROM' line reffers to the type of joing IE, 'JOIN' from LIB.NAME
to LIB2.NAME2 'ON' variable name (`guid` in this case)



a more crude alternative is this:

#+begin_src sas
libname grid "S:\ENVEPI\Tania\grids";
proc sort data=grid.Outputfile;
	by guid;
run;
proc sort data=grid.Zipguid;
	by guid zipcode;
run;
/*  Create a dataset with unique numbers for ZIP's and GUID's */
data Zipguid(drop=cnt) ZipguidNbr(keep=guid zipnbr rename=(zipnbr=maxzipnbr));
	retain cnt 0;
	set grid.Zipguid;;
	by guid;
	if first.guid then cnt=0;
	cnt+1;
	zipnbr=cnt;
	output Zipguid;
	if last.guid then output ZipguidNbr;
run;
/* prepare the Outputfile dataset by merging with the ZipguidNbr */
data Outputfile (drop=i);
  merge grid.Outputfile(in=a)
  ZipguidNbr(in=b);
  by guid;
  if b;
/* per guid - output multiple records - one per zip */
  do i =1 to maxzipnbr;
    zipnbr=i;
    output;
  end;
run;
/* we now finaly merge Zipguid with Outputfile */
proc sort data=Outputfile;
	by guid zipnbr;
run;
proc sort data=Zipguid;
	by guid zipnbr;
run;


data grid.mrgfl(drop=zipnbr maxzipnbr);
	merge  Zipguid Outputfile;
	by guid zipnbr;
run;
#+end_src

*** in variable example

here is an example of the in statement:
 proc sort data= lu;
 by guid;
 run;
 proc sort data= aod;
 by guid;
 run;
 data aod2;
 merge aod (in=a) lu (in=b) ;
 by guid;
 if a;
 run;
 in the above example code only observations from the aod dataset (the
'a' ) will be included in the final outputed dataset
 To use the keep statement put it inside the () with the in IE:
 data aod4 ;
 merge aod3 (in=a) guid\_ids (in=b keep=guid stn) ;
 by guid;
 if=a;
 run;

*** How do you know when you merged correctly?

*How do you know when you merged correctly?*
 Before doing a merge, ask yourself these questions:
 Do you know your input data sets to MERGE?
 Is each input data set sorted by the BY-variables?
 Are the BY-variables named the same in each input data set? If
not, you will need to do some renaming.
 Are there other common variables that are not used in the by
statement? If yes, watch out--results may surprise you.
 How many observations and how many variables are in the input
data sets?
 Do you need to keep all variables in the input data sets? If not,
you may want to use the DROP= or KEEP= data set options.
 Can you predict the number of variables in the output (merged) data
set? (always possible)
 Can you predict the N of the output data set? (not always possible,
but it's a good idea to ask yourself this question anyhow)
 Test your program: print and examine observations BEFORE and AFTER the
merge.
 Finally, take time to examine the log carefully.

*** Adding Rows (append)

to add rows from another dataset
 1)make sure they are all in sas format (use the import function if not)
 2)issue a proc append statment :
 PROC APPEND BASE=terra.ALL DATA=terra.D02\_m03\_2000;
 RUN;
 in the above code :
 1)first define the library name and place
 then in *base* define the file that data would *be added* to (this
could be a existing or an empty file like in this case)
 in *Data*put the data to be joined to the base data file
 in a macro:
 /*append every iteration to oned file*/
 proc append base=LST2000 data = &filename;
 run;

*** Adding Rows (data-set)

an alternative way to proc append is to just use the data and set
commands:
 data NEWDATA;
 set OLDDATA1 OLDDATA2 OLDDATA3;
 run;

*** Combine two variables
Creating a new variable by compressing several variables:
 This is done using the *||* command

 Combine factors using ||, remove any trailing blank using *COMPRESS*
 Combine variables with||, remove any trialing blank using TRIM

 example:
 data merg.step7\_2001;
 set merg.step6\_2001;
 UID=compress(xnym||ynym);
 run;

*** Proc SQL
**** Joins using proc SQL FULL example compared to SAS merge
#+BEGIN_SRC SAS
data DATA_A;
 input ID Group Var;
cards;
1 1 10
2 1 11
3 1 12
4 2 13
5 2 14
6 2 15
7 3 .
8 1 .
;
run;

data DATA_B;
 input ID Group;
cards;
1 1
2 1
4 2
6 2
9 3
;
run;

/**** First Method *****/

proc sort data = DATA_A; by ID Group ;run;
proc sort data = DATA_B; by ID Group ;run;

data DATA_C_in_a;
merge DATA_A(in=a) DATA_B(in=b);
  by ID Group ;
    if a;
run;

data DATA_C_in_b;
merge DATA_A(in=a) DATA_B(in=b);
  by ID Group ;
    if b;
run;

data DATA_C_in_ab;
merge DATA_A(in=a) DATA_B(in=b);
  by ID Group ;
    if a and b;
run;


/***** Second Method *****/

/***  Like merge with (in = a) ***/

proc sql;
  create table DATA_C1_in_a as
   select *
    from DATA_A left join DATA_B(rename=(id=tmpid) rename=(group=tmpgroup))
     on DATA_A.ID = DATA_B.tmpid and DATA_A.Group  = DATA_B.tmpgroup;
run;

/***  Like merge with (in = b) ***/

proc sql;
  create table DATA_C1_in_b as
   select *
    from DATA_A right join DATA_B(rename=(id=tmpid) rename=(group=tmpgroup))
     on DATA_A.ID = DATA_B.tmpid and DATA_A.Group  = DATA_B.tmpgroup;
run;

/***  Like merge with if a and b ***/

proc sql;
  create table DATA_C1_ab(drop=tmpid tmpgroup) as
   select *
    from DATA_A, DATA_B(rename=(id=tmpid) rename=(group=tmpgroup))
     where DATA_A.ID = DATA_B.tmpid and DATA_A.Group  = DATA_B.tmpgroup;
run;

#+END_SRC

**** Simple Join ("left join"/in a or ("right join"/in b )
!$Note!-if using library names only use them in the 'from' line and not
the 'on' line

#+BEGIN_SRC SAS
/****left Join (IN=b)  *****/
proc sql;
  create table NEWDATA  as
   select *
    from DATA1 left join DATA2
     on DATA1.VAR1 = DATA2.VAR1 and on DATA1.VAR2 = DATA2.VAR2 ;
run;

/****Right Join (IN=b)  *****/
proc sql;
  create table NEWDATA  as
   select *
    from DATA1 right join DATA2
     on DATA1.VAR1 = DATA2.VAR1 and on DATA1.VAR2 = DATA2.VAR2 ;
run;
#+END_SRC

** string/character variables
*** combine 2 string (text) variables

use the compress command and use double pipes '||" between each variable
 For example:

*** create guid variable (compress variables))

use the following code:
 data aod\_2000\_v2 (drop= x1 y2);
 set aod\_2000;
 x1 = x*-100;
 y2 = y*100;
 guid=compress(x1||y2);
 run;

 /*to create guid as numeric instead of character*/
 data aod\_2000\_v3 (drop=guid) ;
 set aod\_2000\_v2;
 guid2=input(guid, 8.);
 run;
 data aod\_2000\_v4;
 set aod\_2000\_v3(rename=(guid2=guid));
 run;

*** subtract part of the text

*SAS SUBSTR( )* is mainly used for extracting a part of string. But more
interestingly it has got another important use as well.
 When we use it on the Left side of assignment statement it can be used
to replace the part of string in main string.

 So when used on Right side its extracting part of string and when used
on left side it can used for replacing the part of string in original
string.

 data temp;
 sample_str = "Pin Code 411014";
 all_str = SUBSTR(sample_str,1);
 wrong_lngth = SUBSTR(sample_str,5,100);
 wrong_strt = SUBSTR(sample_str,100,2);
 run;

 If we see the code more closely;
 The first assignment statement
 all\_str = SUBSTR(sample\_str,1);
 dont have Third argument; and as the corresponding output we get is all
the string.

 It means third argument is optional; and if its missing SUSTR() returns
all the remaining string starting with given position. (its 1 in this
case).

 the second assignment statement is the standard demonstration of the
SUBSTR () function;
 mid\_str = SUBSTR(sample\_str,5,4);

 As we can see from the output; SUBSTR() has returned the part of
string; starting at 5th position and counting 4 characters then onwards.

 The third assignment statements again demonstrates; what happens if
provide the invalid length as third argument;
 wrong\_lngth = SUBSTR(sample\_str,5,100);
 and the output as we can see; SUBSTR() returned the all remaining
string starting from given position. But its worth to note the note
displayed in the log.
 NOTE: Invalid third argument to function SUBSTR at line 19 column 15.
 Similarly in the Fourth assignment statement; we can see what happens
when we give the invalied start position; which is actually out of
bounds of the original string.
 wrong\_strt = SUBSTR(sample\_str, 100,2);
 And we can observe the output to be blank; in addition to following
NOTE being displayed in the log.
 NOTE: Invalid second argument to function SUBSTR at line 20 column 14.

*** compress

SAS COMPRESS () Function is used to remove given characters from the
string. Users have the facility to remove a single specific character or
a group of characters from the target string. All they have to do is
provide the list of characters to be removed as second argument to the
function.However this second argument is optional to thefunction and in
absence of this COMPRESS () function will remove all BLANKS from the
given string.This has been demonstrated below;1. SASCOMPRESS( )
FunctionSYNTAX:COMPRESS(char\_stirng,
'char\_list\_to\_be\_removed'<optional>);
 Example: SAS COMPRESS( ) Function
 data temp;
 ph\_no = "011- 22 33344(1212)";
 ph\_no\_without\_blanks = COMPRESS(ph\_no);
 ph\_no\_only\_numbers = COMPRESS(ph\_no, '()-');
 /* Note the second argument to the function as list
 of characters to be removed */
 run;

 proc print data = temp;
 run;
 ph\_no\_without\_blanks = COMPRESS(ph\_no);

 Where we haven't supplied the second argument to the function we can
observe that COMPRESS () has removed all the blanks from the string.



 While at the Second Statement

 ph\_no\_only\_numbers = COMPRESS(ph\_no, '()-');

 We have supplied the list of characters enclosed in single quote
including BLANK character; and hence removed all the individual
occurrences of these characters.



 Pasted from
<[[https://sites.google.com/site/sasbuddy/sas-string-function-compress][https://sites.google.com/site/sasbuddy/sas-string-function-compress]]>

** Reshaping Data

** Subsetting Data
*** subset by date range

data DATAOUT (where=(date>="01JAN2003"*D* and date<="31DEC2003"D ));
 set DATA;
 run;
 the D indicates to sas its a date
*** subset big data set by a variable id
use this:

#+begin_src sas

data out2000;
set mods.Fintmpc_2000;
 if guid in ("-692066445716",
"-696283438608",
"-731946444753",
"-733513441258",
"-733995411016",
"-733995439813");
run;
#+end_src

*** subset by number (n)

this example subsets the dataset to 5 cases:
 **

data bw15;
 set bw11;
 if \_n\_ < *5*;
 *run*;
*** subset database to a specific row
you can again use 'n'
₆In example₆

#+BEGIN_SRC sas
data X;
set Y;
if _n_ =2;
run;
#+END_SRC

will only select the 2nd case (row) for the orig database (Y) 
*** subset by a charcter variable
see this example
#+begin_src sas
data zinclp;
set zinc;
where Location ="Walpeup, Australia";
run;
#+end_src

*** split big datasets into chunks

 *data* A1 A2 A3 A4 A5 A6 A7 A8 A9 A10;
 set mod2\_2003\_s3;
 if *1* <= \_n\_ <= *10000000* then output A1;
 if *10000001* <= \_n\_ <= *20000000* then output A2;
 if *20000001* <= \_n\_ <= *30000000* then output A3;
 if *30000001* <= \_n\_ <= *40000000* then output A4;
 if *40000001* <= \_n\_ <= *50000000* then output A5;
 if *50000001* <= \_n\_ <= *60000000* then output A6;
 if *60000001* <= \_n\_ <= *70000000* then output A7;
 if *70000001* <= \_n\_ <= *80000000* then output A8;
 if *80000001* <= \_n\_ <= *90000000* then output A9;
 if *90000001* <= \_n\_ <= *100000000* then output A10;
 *run*;

*** subset by absolute values

use the abs function

 *data* xx;
 set Pdataa\_2003;
 if abs(resid) > *10*;
 *run*;

** Data Type Conversion

*** Convert from character to numeric and visa versa

How can I convert my data from character to numeric and visa versa using
SAS functions?
 To convert CHARACTER values to NUMERIC values you use the INPUT
function
 to convert NUMERIC values to CHARACTER values you use the PUT function.
 The form of the INPUT and PUT functions is as follows:
 INPUT(source,informat)
 PUT(source,format)
 *for example to convert from text to numeric:*
 data t2001\_aodp\_v2;
 set t2001\_aodp;
 guid2=input(guid, 8.);
 drop guid;
 run;
 *NOTE: sometimes its quicker to do this:*
 sitecodex=sitcode*1;
 *for example to convert from numeric to text:
*data PMSTAT\_20012;
 set PMSTAT\_2001;
 sitecodex=put(sitecode,10.0);
 run;

*** convert from numeric to character

Converting a Numeric Variable to a Character Variable
 This is an example of how to change a numeric variable, ID, to
character variable.
 This example uses PUT function to convert numeric data to character
data. The PUT function writes values with a specified format. It takes
two arguments: the name of the numeric variable and a SAS format or
user-defined format for writing the data.
 char\_id = put(id, 7.) ;
 drop id ;
 rename char\_id=id ;
 Below are a few examples of data conversions using the PUT function:
 [convert numeric variable "oldvar"(length) to character variable
"newvar"(length)] oldvar put function newvar]
 303 (8) newvar=put(oldvar, 3.); 303 (3)
 32000 (8) newvar=put(oldvar, dollar7.); $32,000 (7)
 366 (8) newvar=put(oldvar, date9.); 01jan1961 (9)

** Rename variables
*** rename variables
To rename a variable in SAS issue set=DB and data=new dataset. in the
set command add the (rename=(OLD\_name=NEW\_name)) command to rename the
variable:
for example:

 data merg.T2000\_All\_AOD\_step1;
 set merg.T2000\_All\_AOD(rename=(date\_=date2));
 run;

 if you have multiple variables use:
 data HDAT.death1\_s2;
 set HDAT.death1(rename=(longitude=x latitude=y));
 run;


NOTE: SAS dosent change the variable lables so dont get confused
or in data step:

data allx;
set all;
rename lon=x lat=y;
run;

*** rename method2

create clone variable with diff name and drop old name:
 data DATA(drop=OLDVAR1 OLDVAR1 );
 set DATA;
 VAR1 =OLDVAR1;
 VAR2=OLDVAR2
 run;

** Dates
*** date and time formats

[[./sas_files/attach/date_time.pdf][Attachment #04 (date\_time.pdf)]]
 for a more comprehensive view see attached pdf
 1)formating date to a classic date format:
 format DATE mmddyy8.;
 2)the TODAY function returns the current date
 Date formats:
 DATE9. 17MAR2000
 mmddyy10. 04/01/2001

*** create a data field (sas date functions)

*SAS Date Functions*
 The date functions that are available in SAS can be used to:
 create date values
 take apart date values
 massage date values (what??!)
 calculate intervals
 For no particular reason, we'll look at them in that order.
 Using functions to create date values
 The functions that can be used to create date values include:
 date( ) returns today's date as a SAS date value
 today( ) returns today's date as a SAS date value
 mdy(m,d,y) returns a SAS date value from the given month (m), day
(d), and year (y) values
 datejul(juldate) converts a Julian date (juldate) to a SAS date
value
 yyq(y, q) returns a SAS date value from the given year (y) and
quarter (q) 1, 2, 3, or 4
 The date( ) and today( ) functions are equivalent. That is, they both
return the current date as defined as the date on which the SAS program
is executed. You don't need to put anything in between the parentheses
for those two functions.
 A Julian date is defined in SAS as a date in the form yyddd or yyyyddd,
where yy or yyyy is a two-digit or four-digit integer that represents
the year and ddd is the number of the day of the year. The value of ddd
must be between 001 and 365 (or 366 for a leap year). So, for example,
the SAS Julian date for January 21, 2008 is 2008021.
 *Example:*
 to create a date field for the 1.1.2000:
 **

data nasguid;
 set nasguid;
 drop OBJECTID Join\_Count target\_fid;
 date= mdy(*1*,*1*,*2000*);
 format DATE mmddyy8.;
 *run*;
 NOTE: first you put in the date and sas converts into local SAS date
then use the format option to convert to regular date

*** convert between SAS date formats

use the format command and choose the deired date (date9. , ddmmyy10.
etc..)
 data pm0002(drop=date2);
 set pm0002;
 date= date2;
 format date ddmmyy10.;
 run;

*** convert numric date to character

#+begin_src sas
data xx;
set tncdc;
newvar=put(date, date9.);
run;
#+end_src

you can also add another data step to extract part of that date

#+begin_src sas
data xx;
set tncdc;
newvar=put(date, date9.);
Gender = substr(newvar,1,5);
run;
#+end_src

*** convert a character date to a numeric date
if you have a character date like this 01APR05

use this

#+BEGIN_SRC sas
data cases ;
set cases;
date=input(adate,date9.);
format date mmddyy10.;
run;
#+END_SRC
this example converts a formated date in text (IE 01/01/2010) to numeric
and then reformats it into date format:
 data T2001\_bimon1;
 set T2001\_bimon1;
 newdate = input(date,mmddyy10.);
 format newdate mmddyy10.;
 run;
 where the format is mm/dd/yyyy (note that in SAS there is no need for
yyyy just yy)
 the first step formats the date as a number and the second step formats
the number as date
 *
 Example:*
 data T2003\_mod2pred\_v2;
 set T2003\_mod2pred ;
 newdate = input(date,mmddyy10.);
 format newdate mmddyy10.;
 drop date;
 run;
 data T2003\_mod2pred\_v3;
 set T2003\_mod2pred\_v2(rename=(newdate=date ));;
 run;

*** convert a complex string to date

this example shows a rare date format : 20090327
 20090327
 day
 month
 year
 1) first extract the date format using the *substr* command
 data only14\_v2;
 set only14;
 c=substr(dd,1,4);
 m=substr(dd,5,2);
 d=substr(dd,7,2);
 date=mdy(m,d,c);
 format date date7.;
 run;
 m=creates a variable mm from the dd variable.
 1,4 this means starts at point 1 and is 4 characters long
 date=the new date variable composed of the individual extracted -
"*date7*" is the most common format for dates in sas.
 The last part would be to clean unwanted variables.

------------------------------------------------------------------------------------------------------------------
 data h.poll; set poll2;
 drop mm dd yy month day year date2;
 run;

------------------------------------------------------------------------------------------------------------------

*** extract part of dates to variables (create month/day/year vars)

here are some commands one can use to extract parts of a date variable:
 DATE = today();
 day = day(DATE);
 month = month(DATE);
 year = year(DATE);
 qtr = qtr(DATE);
 weekday = weekday(DATE);
 week = week(DATE);
 *example:*
 data T2003\_mod2pred\_v5;
 set T2003\_mod2pred\_v4;
 m = month(date);
 run;
 *where:*
 m-is the new variable
 month-is the command
 date-is the date variable

*** create day of the year variable
use the following code:
#+begin_src sas
data xx;
set tncdc;
format date JULDAY.;
run;
#+end_src

where 'JULDAY' is the day of the year function

*** julian dates
*** convert 2 parts of date (year,julian day) into date

to convert 2 parts of a date (year,julian day) into date
 first make sure that both parts are characters
 then combine the 2 variables into one continous julian date standart
format:
 yyyyddd
 IE
 data Mod2\_2003allv4;
 set Mod2\_2003allv3;
 juldate=compress(jy||jul);
 run;
 then format the julian dates into real dates by first converting the
combined text variable (juldate in example) into a julian date proper
(newjul) and then converting that into a real date.
 data Mod2\_2003allv5 ;
 set Mod2\_2003allv4;
 newjul= input(juldate,julian7.);
 date=newjul;
 format DATE mmddyy8.;
 run;
**** format julian date
#+begin_src sas
data times4;
set times;
if pmnew_l1 = . then delete;
format date JULIAN.;
run;
#+end_src

*** extract a long string of julian date (MIAC data example)
use this code when the date is julian and has hours and time IE: ~20030021710~

#+BEGIN_SRC SAS
data DATA2;
set DATA ;
  char_id = put(JULDATE, 12.) ;
  Jdata = (SUBSTR (char_id, 1,8))*1;
  DATE = DATEJUL(Jdata);
  HH = (SUBSTR (char_id, 9,2))*1;
  MM = (SUBSTR (char_id, 11,2))*1;
   Format DATE date9.;
run;
#+END_SRC

*** seasons
**** code to put 2 seasons

data T2000ALL\_v8;
 set T2000ALL\_v7;
 season=1;
 if m=1 or m=2 or m=3 or m=10 or m=11 or m=12 then season=0;
 run;

**** code to transfrom date to 4 season

Code for Season:
 data data;
 set data;
 mon=month(date);
 if (mon=1 or mon=2 or mon=12 or mon=11) then winter=1; else winter=0;
 if (mon=3 or mon=4 or mon=5) then spring=1; else spring=0;
 if (mon=6 or mon=7 or mon=8) then summer=1; else summer=0;
 if (mon=9 or mon=10) then fall=1; else fall=0;
 run;
 or a detailed code with aggregation per season
 **

data lst2003pre\_season;
 set lst2003pre;
 Month = month(date);
 if Month in (*3*,*4*,*5*) then Season = "Spring";
 if Month in (*6*,*7*,*8*) then Season = "Summer";
 if Month in (*9*,*10*,*11*) then Season = "Autumn";
 if Month in (*12*,*1*,*2*) then Season = "Winter";
 *run*;

 *proc* *summary* data = lst2003pre\_season nway;
 class xx yy season ;
 var Dtckin ntckin;
 output out = Aggregate(drop = \_Type\_ \_Freq\_) mean(Dtckin) =
Dtckin mean(ntckin) = ntckin ;
 *run*;
 *quit*;

 *data* Summer;
 set Aggregate;
 if Season = "Summer";
 *run*;
 *quit*;

 *data* Autumn;
 set Aggregate;
 if Season = "Autumn";
 *run*;
 *quit*;


 *data* Winter;
 set Aggregate;
 if Season = "Winter";
 *run*;
 *quit*;


 *data* Spring;
 set Aggregate;
 if Season = "Spring";
 *run*;
 *quit*;
 *PROC* *EXPORT* DATA= Summer
 OUTFILE= "c:\Users\ekloog\Documents\tmp\Summer.dbf"
 DBMS=DBF REPLACE;
 *RUN*;

 *PROC* *EXPORT* DATA= Winter
 OUTFILE= "c:\Users\ekloog\Documents\tmp\Winter.dbf"
 DBMS=DBF REPLACE;
 *RUN*;

 *PROC* *EXPORT* DATA= Spring
 OUTFILE= "c:\Users\ekloog\Documents\tmp\Spring.dbf"
 DBMS=DBF REPLACE;
 *RUN*;

 *PROC* *EXPORT* DATA= Autumn
 OUTFILE= "c:\Users\ekloog\Documents\tmp\Autumn.dbf"
 DBMS=DBF REPLACE;
 *RUN*;

 ;

**** cos/sin to control for seasonality

use this code:
#+begin_src sas
dow=weekday(date);
doy=put (date,julian5.);
doy2=substr(doy,3,3);
sinetime=sin(2*constant('pi')*doy2/365.25);
costime=cos(2*constant('pi')*doy2/365.25);
#+end_src

*** Creating Date and Time Variables from Numeric and/or Character
Variables

*Creating Date and Time Variables from Numeric and/or Character
Variables*
 Let's look at some code that takes character values for month day and
year and combine all three to generate a
 SAS date:

 data \_null\_;
 month='06';
 day='15';
 year='02';
 date = mdy(input(month,2.),input(day,2.),input(year,2.));
 put date=;
 run;

 Output from the source code:

 date=15506

*** convert months to bimonths

use this code:
 data T2003\_mod2pred\_v5;
 set T2003\_mod2pred\_v4;
 m = month(date);
 if (m=1 or m=2) then bimon=1;
 if (m=3 or m=4) then bimon=2;
 if (m=5 or m=6) then bimon=3;
 if (m=7 or m=8) then bimon=4;
 if (m=9 or m=10) then bimon=5;
 if (m=11 or m=12) then bimon=6;
 run;

*** Batch create dates from multiple files (full grid example)

Use the following example sas script:
 /*#import mod 2 joind files*/
 PROC IMPORT OUT=a2000\_001 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_002 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_003 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_004 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_005 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_006 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_007 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_008 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_009 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_010 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_011 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_012 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_013 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_014 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_015 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_016 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_017 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_018 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_019 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_020 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_021 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_022 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_023 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_024 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_025 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_026 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_027 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_028 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_029 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_030 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_031 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_032 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_033 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_034 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_035 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_036 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_037 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_038 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_039 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_040 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_041 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_042 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_043 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_044 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_045 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_046 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_047 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_048 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_049 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_050 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_051 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_052 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_053 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_054 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_055 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_056 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_057 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_058 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_059 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_060 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_061 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_062 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_063 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_064 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_065 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_066 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_067 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_068 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_069 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_070 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_071 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_072 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_073 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_074 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_075 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_076 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_077 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_078 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_079 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_080 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_081 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_082 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_083 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_084 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_085 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_086 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_087 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_088 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_089 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_090 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_091 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_092 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_093 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_094 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_095 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_096 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_097 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_098 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_099 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_100 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_101 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_102 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_103 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_104 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_105 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_106 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_107 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_108 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_109 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_110 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_111 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_112 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_113 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_114 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_115 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_116 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_117 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_118 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_119 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_120 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_121 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_122 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_123 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_124 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_125 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_126 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_127 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_128 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_129 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_130 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_131 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_132 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_133 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_134 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_135 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_136 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_137 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_138 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_139 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_140 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_141 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_142 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_143 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_144 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_145 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_146 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_147 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_148 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_149 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_150 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_151 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_152 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_153 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_154 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_155 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_156 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_157 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_158 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_159 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_160 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_161 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_162 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_163 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_164 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_165 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_166 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_167 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_168 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_169 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_170 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_171 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_172 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_173 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_174 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_175 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_176 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_177 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_178 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_179 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_180 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_181 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_182 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_183 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_184 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_185 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_186 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_187 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_188 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_189 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_190 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_191 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_192 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_193 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_194 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_195 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_196 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_197 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_198 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_199 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_200 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_201 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_202 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_203 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_204 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_205 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_206 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_207 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_208 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_209 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_210 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_211 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_212 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_213 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_214 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_215 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_216 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_217 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_218 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_219 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_220 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_221 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_222 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_223 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_224 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_225 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_226 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_227 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_228 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_229 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_230 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_231 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_232 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_233 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_234 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_235 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_236 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_237 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_238 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_239 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_240 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_241 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_242 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_243 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_244 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_245 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_246 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_247 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_248 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_249 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_250 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_251 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_252 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_253 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_254 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_255 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_256 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_257 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_258 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_259 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_260 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_261 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_262 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_263 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_264 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_265 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_266 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_267 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_268 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_269 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_270 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_271 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_272 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_273 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_274 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_275 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_276 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_277 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_278 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_279 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_280 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_281 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_282 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_283 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_284 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_285 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_286 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_287 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_288 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_289 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_290 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_291 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_292 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_293 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_294 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_295 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_296 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_297 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_298 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_299 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_300 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_301 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_302 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_303 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_304 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_305 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_306 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_307 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_308 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_309 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_310 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_311 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_312 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_313 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_314 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_315 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_316 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_317 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_318 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_319 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_320 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_321 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_322 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_323 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_324 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_325 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_326 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_327 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_328 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_329 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_330 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_331 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_332 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_333 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_334 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_335 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_336 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_337 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_338 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_339 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_340 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_341 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_342 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_343 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_344 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_345 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_346 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_347 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_348 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_349 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_350 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_351 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_352 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_353 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_354 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_355 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_356 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_357 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_358 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_359 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_360 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_361 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_362 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_363 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 PROC IMPORT OUT=a2000\_364 DATAFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.2.MIA\_PM\_MODELS\3.1.2.4.Work\2.Gather\_data\create\_guid\grid\_guid\_reg.dbf"
DBMS=DBF REPLACE ;GETDELETED=NO; RUN;
 /*Add date to files*/
 data a2000\_001\_v2 ; set a2000\_001 ; jy='2000'; jul='001'; run;
 data a2000\_002\_v2 ; set a2000\_002 ; jy='2000'; jul='002'; run;
 data a2000\_003\_v2 ; set a2000\_003 ; jy='2000'; jul='003'; run;
 data a2000\_004\_v2 ; set a2000\_004 ; jy='2000'; jul='004'; run;
 data a2000\_005\_v2 ; set a2000\_005 ; jy='2000'; jul='005'; run;
 data a2000\_006\_v2 ; set a2000\_006 ; jy='2000'; jul='006'; run;
 data a2000\_007\_v2 ; set a2000\_007 ; jy='2000'; jul='007'; run;
 data a2000\_008\_v2 ; set a2000\_008 ; jy='2000'; jul='008'; run;
 data a2000\_009\_v2 ; set a2000\_009 ; jy='2000'; jul='009'; run;
 data a2000\_010\_v2 ; set a2000\_010 ; jy='2000'; jul='010'; run;
 data a2000\_011\_v2 ; set a2000\_011 ; jy='2000'; jul='011'; run;
 data a2000\_012\_v2 ; set a2000\_012 ; jy='2000'; jul='012'; run;
 data a2000\_013\_v2 ; set a2000\_013 ; jy='2000'; jul='013'; run;
 data a2000\_014\_v2 ; set a2000\_014 ; jy='2000'; jul='014'; run;
 data a2000\_015\_v2 ; set a2000\_015 ; jy='2000'; jul='015'; run;
 data a2000\_016\_v2 ; set a2000\_016 ; jy='2000'; jul='016'; run;
 data a2000\_017\_v2 ; set a2000\_017 ; jy='2000'; jul='017'; run;
 data a2000\_018\_v2 ; set a2000\_018 ; jy='2000'; jul='018'; run;
 data a2000\_019\_v2 ; set a2000\_019 ; jy='2000'; jul='019'; run;
 data a2000\_020\_v2 ; set a2000\_020 ; jy='2000'; jul='020'; run;
 data a2000\_021\_v2 ; set a2000\_021 ; jy='2000'; jul='021'; run;
 data a2000\_022\_v2 ; set a2000\_022 ; jy='2000'; jul='022'; run;
 data a2000\_023\_v2 ; set a2000\_023 ; jy='2000'; jul='023'; run;
 data a2000\_024\_v2 ; set a2000\_024 ; jy='2000'; jul='024'; run;
 data a2000\_025\_v2 ; set a2000\_025 ; jy='2000'; jul='025'; run;
 data a2000\_026\_v2 ; set a2000\_026 ; jy='2000'; jul='026'; run;
 data a2000\_027\_v2 ; set a2000\_027 ; jy='2000'; jul='027'; run;
 data a2000\_028\_v2 ; set a2000\_028 ; jy='2000'; jul='028'; run;
 data a2000\_029\_v2 ; set a2000\_029 ; jy='2000'; jul='029'; run;
 data a2000\_030\_v2 ; set a2000\_030 ; jy='2000'; jul='030'; run;
 data a2000\_031\_v2 ; set a2000\_031 ; jy='2000'; jul='031'; run;
 data a2000\_032\_v2 ; set a2000\_032 ; jy='2000'; jul='032'; run;
 data a2000\_033\_v2 ; set a2000\_033 ; jy='2000'; jul='033'; run;
 data a2000\_034\_v2 ; set a2000\_034 ; jy='2000'; jul='034'; run;
 data a2000\_035\_v2 ; set a2000\_035 ; jy='2000'; jul='035'; run;
 data a2000\_036\_v2 ; set a2000\_036 ; jy='2000'; jul='036'; run;
 data a2000\_037\_v2 ; set a2000\_037 ; jy='2000'; jul='037'; run;
 data a2000\_038\_v2 ; set a2000\_038 ; jy='2000'; jul='038'; run;
 data a2000\_039\_v2 ; set a2000\_039 ; jy='2000'; jul='039'; run;
 data a2000\_040\_v2 ; set a2000\_040 ; jy='2000'; jul='040'; run;
 data a2000\_041\_v2 ; set a2000\_041 ; jy='2000'; jul='041'; run;
 data a2000\_042\_v2 ; set a2000\_042 ; jy='2000'; jul='042'; run;
 data a2000\_043\_v2 ; set a2000\_043 ; jy='2000'; jul='043'; run;
 data a2000\_044\_v2 ; set a2000\_044 ; jy='2000'; jul='044'; run;
 data a2000\_045\_v2 ; set a2000\_045 ; jy='2000'; jul='045'; run;
 data a2000\_046\_v2 ; set a2000\_046 ; jy='2000'; jul='046'; run;
 data a2000\_047\_v2 ; set a2000\_047 ; jy='2000'; jul='047'; run;
 data a2000\_048\_v2 ; set a2000\_048 ; jy='2000'; jul='048'; run;
 data a2000\_049\_v2 ; set a2000\_049 ; jy='2000'; jul='049'; run;
 data a2000\_050\_v2 ; set a2000\_050 ; jy='2000'; jul='050'; run;
 data a2000\_051\_v2 ; set a2000\_051 ; jy='2000'; jul='051'; run;
 data a2000\_052\_v2 ; set a2000\_052 ; jy='2000'; jul='052'; run;
 data a2000\_053\_v2 ; set a2000\_053 ; jy='2000'; jul='053'; run;
 data a2000\_054\_v2 ; set a2000\_054 ; jy='2000'; jul='054'; run;
 data a2000\_055\_v2 ; set a2000\_055 ; jy='2000'; jul='055'; run;
 data a2000\_056\_v2 ; set a2000\_056 ; jy='2000'; jul='056'; run;
 data a2000\_057\_v2 ; set a2000\_057 ; jy='2000'; jul='057'; run;
 data a2000\_058\_v2 ; set a2000\_058 ; jy='2000'; jul='058'; run;
 data a2000\_059\_v2 ; set a2000\_059 ; jy='2000'; jul='059'; run;
 data a2000\_060\_v2 ; set a2000\_060 ; jy='2000'; jul='060'; run;
 data a2000\_061\_v2 ; set a2000\_061 ; jy='2000'; jul='061'; run;
 data a2000\_062\_v2 ; set a2000\_062 ; jy='2000'; jul='062'; run;
 data a2000\_063\_v2 ; set a2000\_063 ; jy='2000'; jul='063'; run;
 data a2000\_064\_v2 ; set a2000\_064 ; jy='2000'; jul='064'; run;
 data a2000\_065\_v2 ; set a2000\_065 ; jy='2000'; jul='065'; run;
 data a2000\_066\_v2 ; set a2000\_066 ; jy='2000'; jul='066'; run;
 data a2000\_067\_v2 ; set a2000\_067 ; jy='2000'; jul='067'; run;
 data a2000\_068\_v2 ; set a2000\_068 ; jy='2000'; jul='068'; run;
 data a2000\_069\_v2 ; set a2000\_069 ; jy='2000'; jul='069'; run;
 data a2000\_070\_v2 ; set a2000\_070 ; jy='2000'; jul='070'; run;
 data a2000\_071\_v2 ; set a2000\_071 ; jy='2000'; jul='071'; run;
 data a2000\_072\_v2 ; set a2000\_072 ; jy='2000'; jul='072'; run;
 data a2000\_073\_v2 ; set a2000\_073 ; jy='2000'; jul='073'; run;
 data a2000\_074\_v2 ; set a2000\_074 ; jy='2000'; jul='074'; run;
 data a2000\_075\_v2 ; set a2000\_075 ; jy='2000'; jul='075'; run;
 data a2000\_076\_v2 ; set a2000\_076 ; jy='2000'; jul='076'; run;
 data a2000\_077\_v2 ; set a2000\_077 ; jy='2000'; jul='077'; run;
 data a2000\_078\_v2 ; set a2000\_078 ; jy='2000'; jul='078'; run;
 data a2000\_079\_v2 ; set a2000\_079 ; jy='2000'; jul='079'; run;
 data a2000\_080\_v2 ; set a2000\_080 ; jy='2000'; jul='080'; run;
 data a2000\_081\_v2 ; set a2000\_081 ; jy='2000'; jul='081'; run;
 data a2000\_082\_v2 ; set a2000\_082 ; jy='2000'; jul='082'; run;
 data a2000\_083\_v2 ; set a2000\_083 ; jy='2000'; jul='083'; run;
 data a2000\_084\_v2 ; set a2000\_084 ; jy='2000'; jul='084'; run;
 data a2000\_085\_v2 ; set a2000\_085 ; jy='2000'; jul='085'; run;
 data a2000\_086\_v2 ; set a2000\_086 ; jy='2000'; jul='086'; run;
 data a2000\_087\_v2 ; set a2000\_087 ; jy='2000'; jul='087'; run;
 data a2000\_088\_v2 ; set a2000\_088 ; jy='2000'; jul='088'; run;
 data a2000\_089\_v2 ; set a2000\_089 ; jy='2000'; jul='089'; run;
 data a2000\_090\_v2 ; set a2000\_090 ; jy='2000'; jul='090'; run;
 data a2000\_091\_v2 ; set a2000\_091 ; jy='2000'; jul='091'; run;
 data a2000\_092\_v2 ; set a2000\_092 ; jy='2000'; jul='092'; run;
 data a2000\_093\_v2 ; set a2000\_093 ; jy='2000'; jul='093'; run;
 data a2000\_094\_v2 ; set a2000\_094 ; jy='2000'; jul='094'; run;
 data a2000\_095\_v2 ; set a2000\_095 ; jy='2000'; jul='095'; run;
 data a2000\_096\_v2 ; set a2000\_096 ; jy='2000'; jul='096'; run;
 data a2000\_097\_v2 ; set a2000\_097 ; jy='2000'; jul='097'; run;
 data a2000\_098\_v2 ; set a2000\_098 ; jy='2000'; jul='098'; run;
 data a2000\_099\_v2 ; set a2000\_099 ; jy='2000'; jul='099'; run;
 data a2000\_100\_v2 ; set a2000\_100 ; jy='2000'; jul='100'; run;
 data a2000\_101\_v2 ; set a2000\_101 ; jy='2000'; jul='101'; run;
 data a2000\_102\_v2 ; set a2000\_102 ; jy='2000'; jul='102'; run;
 data a2000\_103\_v2 ; set a2000\_103 ; jy='2000'; jul='103'; run;
 data a2000\_104\_v2 ; set a2000\_104 ; jy='2000'; jul='104'; run;
 data a2000\_105\_v2 ; set a2000\_105 ; jy='2000'; jul='105'; run;
 data a2000\_106\_v2 ; set a2000\_106 ; jy='2000'; jul='106'; run;
 data a2000\_107\_v2 ; set a2000\_107 ; jy='2000'; jul='107'; run;
 data a2000\_108\_v2 ; set a2000\_108 ; jy='2000'; jul='108'; run;
 data a2000\_109\_v2 ; set a2000\_109 ; jy='2000'; jul='109'; run;
 data a2000\_110\_v2 ; set a2000\_110 ; jy='2000'; jul='110'; run;
 data a2000\_111\_v2 ; set a2000\_111 ; jy='2000'; jul='111'; run;
 data a2000\_112\_v2 ; set a2000\_112 ; jy='2000'; jul='112'; run;
 data a2000\_113\_v2 ; set a2000\_113 ; jy='2000'; jul='113'; run;
 data a2000\_114\_v2 ; set a2000\_114 ; jy='2000'; jul='114'; run;
 data a2000\_115\_v2 ; set a2000\_115 ; jy='2000'; jul='115'; run;
 data a2000\_116\_v2 ; set a2000\_116 ; jy='2000'; jul='116'; run;
 data a2000\_117\_v2 ; set a2000\_117 ; jy='2000'; jul='117'; run;
 data a2000\_118\_v2 ; set a2000\_118 ; jy='2000'; jul='118'; run;
 data a2000\_119\_v2 ; set a2000\_119 ; jy='2000'; jul='119'; run;
 data a2000\_120\_v2 ; set a2000\_120 ; jy='2000'; jul='120'; run;
 data a2000\_121\_v2 ; set a2000\_121 ; jy='2000'; jul='121'; run;
 data a2000\_122\_v2 ; set a2000\_122 ; jy='2000'; jul='122'; run;
 data a2000\_123\_v2 ; set a2000\_123 ; jy='2000'; jul='123'; run;
 data a2000\_124\_v2 ; set a2000\_124 ; jy='2000'; jul='124'; run;
 data a2000\_125\_v2 ; set a2000\_125 ; jy='2000'; jul='125'; run;
 data a2000\_126\_v2 ; set a2000\_126 ; jy='2000'; jul='126'; run;
 data a2000\_127\_v2 ; set a2000\_127 ; jy='2000'; jul='127'; run;
 data a2000\_128\_v2 ; set a2000\_128 ; jy='2000'; jul='128'; run;
 data a2000\_129\_v2 ; set a2000\_129 ; jy='2000'; jul='129'; run;
 data a2000\_130\_v2 ; set a2000\_130 ; jy='2000'; jul='130'; run;
 data a2000\_131\_v2 ; set a2000\_131 ; jy='2000'; jul='131'; run;
 data a2000\_132\_v2 ; set a2000\_132 ; jy='2000'; jul='132'; run;
 data a2000\_133\_v2 ; set a2000\_133 ; jy='2000'; jul='133'; run;
 data a2000\_134\_v2 ; set a2000\_134 ; jy='2000'; jul='134'; run;
 data a2000\_135\_v2 ; set a2000\_135 ; jy='2000'; jul='135'; run;
 data a2000\_136\_v2 ; set a2000\_136 ; jy='2000'; jul='136'; run;
 data a2000\_137\_v2 ; set a2000\_137 ; jy='2000'; jul='137'; run;
 data a2000\_138\_v2 ; set a2000\_138 ; jy='2000'; jul='138'; run;
 data a2000\_139\_v2 ; set a2000\_139 ; jy='2000'; jul='139'; run;
 data a2000\_140\_v2 ; set a2000\_140 ; jy='2000'; jul='140'; run;
 data a2000\_141\_v2 ; set a2000\_141 ; jy='2000'; jul='141'; run;
 data a2000\_142\_v2 ; set a2000\_142 ; jy='2000'; jul='142'; run;
 data a2000\_143\_v2 ; set a2000\_143 ; jy='2000'; jul='143'; run;
 data a2000\_144\_v2 ; set a2000\_144 ; jy='2000'; jul='144'; run;
 data a2000\_145\_v2 ; set a2000\_145 ; jy='2000'; jul='145'; run;
 data a2000\_146\_v2 ; set a2000\_146 ; jy='2000'; jul='146'; run;
 data a2000\_147\_v2 ; set a2000\_147 ; jy='2000'; jul='147'; run;
 data a2000\_148\_v2 ; set a2000\_148 ; jy='2000'; jul='148'; run;
 data a2000\_149\_v2 ; set a2000\_149 ; jy='2000'; jul='149'; run;
 data a2000\_150\_v2 ; set a2000\_150 ; jy='2000'; jul='150'; run;
 data a2000\_151\_v2 ; set a2000\_151 ; jy='2000'; jul='151'; run;
 data a2000\_152\_v2 ; set a2000\_152 ; jy='2000'; jul='152'; run;
 data a2000\_153\_v2 ; set a2000\_153 ; jy='2000'; jul='153'; run;
 data a2000\_154\_v2 ; set a2000\_154 ; jy='2000'; jul='154'; run;
 data a2000\_155\_v2 ; set a2000\_155 ; jy='2000'; jul='155'; run;
 data a2000\_156\_v2 ; set a2000\_156 ; jy='2000'; jul='156'; run;
 data a2000\_157\_v2 ; set a2000\_157 ; jy='2000'; jul='157'; run;
 data a2000\_158\_v2 ; set a2000\_158 ; jy='2000'; jul='158'; run;
 data a2000\_159\_v2 ; set a2000\_159 ; jy='2000'; jul='159'; run;
 data a2000\_160\_v2 ; set a2000\_160 ; jy='2000'; jul='160'; run;
 data a2000\_161\_v2 ; set a2000\_161 ; jy='2000'; jul='161'; run;
 data a2000\_162\_v2 ; set a2000\_162 ; jy='2000'; jul='162'; run;
 data a2000\_163\_v2 ; set a2000\_163 ; jy='2000'; jul='163'; run;
 data a2000\_164\_v2 ; set a2000\_164 ; jy='2000'; jul='164'; run;
 data a2000\_165\_v2 ; set a2000\_165 ; jy='2000'; jul='165'; run;
 data a2000\_166\_v2 ; set a2000\_166 ; jy='2000'; jul='166'; run;
 data a2000\_167\_v2 ; set a2000\_167 ; jy='2000'; jul='167'; run;
 data a2000\_168\_v2 ; set a2000\_168 ; jy='2000'; jul='168'; run;
 data a2000\_169\_v2 ; set a2000\_169 ; jy='2000'; jul='169'; run;
 data a2000\_170\_v2 ; set a2000\_170 ; jy='2000'; jul='170'; run;
 data a2000\_171\_v2 ; set a2000\_171 ; jy='2000'; jul='171'; run;
 data a2000\_172\_v2 ; set a2000\_172 ; jy='2000'; jul='172'; run;
 data a2000\_173\_v2 ; set a2000\_173 ; jy='2000'; jul='173'; run;
 data a2000\_174\_v2 ; set a2000\_174 ; jy='2000'; jul='174'; run;
 data a2000\_175\_v2 ; set a2000\_175 ; jy='2000'; jul='175'; run;
 data a2000\_176\_v2 ; set a2000\_176 ; jy='2000'; jul='176'; run;
 data a2000\_177\_v2 ; set a2000\_177 ; jy='2000'; jul='177'; run;
 data a2000\_178\_v2 ; set a2000\_178 ; jy='2000'; jul='178'; run;
 data a2000\_179\_v2 ; set a2000\_179 ; jy='2000'; jul='179'; run;
 data a2000\_180\_v2 ; set a2000\_180 ; jy='2000'; jul='180'; run;
 data a2000\_181\_v2 ; set a2000\_181 ; jy='2000'; jul='181'; run;
 data a2000\_182\_v2 ; set a2000\_182 ; jy='2000'; jul='182'; run;
 data a2000\_183\_v2 ; set a2000\_183 ; jy='2000'; jul='183'; run;
 data a2000\_184\_v2 ; set a2000\_184 ; jy='2000'; jul='184'; run;
 data a2000\_185\_v2 ; set a2000\_185 ; jy='2000'; jul='185'; run;
 data a2000\_186\_v2 ; set a2000\_186 ; jy='2000'; jul='186'; run;
 data a2000\_187\_v2 ; set a2000\_187 ; jy='2000'; jul='187'; run;
 data a2000\_188\_v2 ; set a2000\_188 ; jy='2000'; jul='188'; run;
 data a2000\_189\_v2 ; set a2000\_189 ; jy='2000'; jul='189'; run;
 data a2000\_190\_v2 ; set a2000\_190 ; jy='2000'; jul='190'; run;
 data a2000\_191\_v2 ; set a2000\_191 ; jy='2000'; jul='191'; run;
 data a2000\_192\_v2 ; set a2000\_192 ; jy='2000'; jul='192'; run;
 data a2000\_193\_v2 ; set a2000\_193 ; jy='2000'; jul='193'; run;
 data a2000\_194\_v2 ; set a2000\_194 ; jy='2000'; jul='194'; run;
 data a2000\_195\_v2 ; set a2000\_195 ; jy='2000'; jul='195'; run;
 data a2000\_196\_v2 ; set a2000\_196 ; jy='2000'; jul='196'; run;
 data a2000\_197\_v2 ; set a2000\_197 ; jy='2000'; jul='197'; run;
 data a2000\_198\_v2 ; set a2000\_198 ; jy='2000'; jul='198'; run;
 data a2000\_199\_v2 ; set a2000\_199 ; jy='2000'; jul='199'; run;
 data a2000\_200\_v2 ; set a2000\_200 ; jy='2000'; jul='200'; run;
 data a2000\_201\_v2 ; set a2000\_201 ; jy='2000'; jul='201'; run;
 data a2000\_202\_v2 ; set a2000\_202 ; jy='2000'; jul='202'; run;
 data a2000\_203\_v2 ; set a2000\_203 ; jy='2000'; jul='203'; run;
 data a2000\_204\_v2 ; set a2000\_204 ; jy='2000'; jul='204'; run;
 data a2000\_205\_v2 ; set a2000\_205 ; jy='2000'; jul='205'; run;
 data a2000\_206\_v2 ; set a2000\_206 ; jy='2000'; jul='206'; run;
 data a2000\_207\_v2 ; set a2000\_207 ; jy='2000'; jul='207'; run;
 data a2000\_208\_v2 ; set a2000\_208 ; jy='2000'; jul='208'; run;
 data a2000\_209\_v2 ; set a2000\_209 ; jy='2000'; jul='209'; run;
 data a2000\_210\_v2 ; set a2000\_210 ; jy='2000'; jul='210'; run;
 data a2000\_211\_v2 ; set a2000\_211 ; jy='2000'; jul='211'; run;
 data a2000\_212\_v2 ; set a2000\_212 ; jy='2000'; jul='212'; run;
 data a2000\_213\_v2 ; set a2000\_213 ; jy='2000'; jul='213'; run;
 data a2000\_214\_v2 ; set a2000\_214 ; jy='2000'; jul='214'; run;
 data a2000\_215\_v2 ; set a2000\_215 ; jy='2000'; jul='215'; run;
 data a2000\_216\_v2 ; set a2000\_216 ; jy='2000'; jul='216'; run;
 data a2000\_217\_v2 ; set a2000\_217 ; jy='2000'; jul='217'; run;
 data a2000\_218\_v2 ; set a2000\_218 ; jy='2000'; jul='218'; run;
 data a2000\_219\_v2 ; set a2000\_219 ; jy='2000'; jul='219'; run;
 data a2000\_220\_v2 ; set a2000\_220 ; jy='2000'; jul='220'; run;
 data a2000\_221\_v2 ; set a2000\_221 ; jy='2000'; jul='221'; run;
 data a2000\_222\_v2 ; set a2000\_222 ; jy='2000'; jul='222'; run;
 data a2000\_223\_v2 ; set a2000\_223 ; jy='2000'; jul='223'; run;
 data a2000\_224\_v2 ; set a2000\_224 ; jy='2000'; jul='224'; run;
 data a2000\_225\_v2 ; set a2000\_225 ; jy='2000'; jul='225'; run;
 data a2000\_226\_v2 ; set a2000\_226 ; jy='2000'; jul='226'; run;
 data a2000\_227\_v2 ; set a2000\_227 ; jy='2000'; jul='227'; run;
 data a2000\_228\_v2 ; set a2000\_228 ; jy='2000'; jul='228'; run;
 data a2000\_229\_v2 ; set a2000\_229 ; jy='2000'; jul='229'; run;
 data a2000\_230\_v2 ; set a2000\_230 ; jy='2000'; jul='230'; run;
 data a2000\_231\_v2 ; set a2000\_231 ; jy='2000'; jul='231'; run;
 data a2000\_232\_v2 ; set a2000\_232 ; jy='2000'; jul='232'; run;
 data a2000\_233\_v2 ; set a2000\_233 ; jy='2000'; jul='233'; run;
 data a2000\_234\_v2 ; set a2000\_234 ; jy='2000'; jul='234'; run;
 data a2000\_235\_v2 ; set a2000\_235 ; jy='2000'; jul='235'; run;
 data a2000\_236\_v2 ; set a2000\_236 ; jy='2000'; jul='236'; run;
 data a2000\_237\_v2 ; set a2000\_237 ; jy='2000'; jul='237'; run;
 data a2000\_238\_v2 ; set a2000\_238 ; jy='2000'; jul='238'; run;
 data a2000\_239\_v2 ; set a2000\_239 ; jy='2000'; jul='239'; run;
 data a2000\_240\_v2 ; set a2000\_240 ; jy='2000'; jul='240'; run;
 data a2000\_241\_v2 ; set a2000\_241 ; jy='2000'; jul='241'; run;
 data a2000\_242\_v2 ; set a2000\_242 ; jy='2000'; jul='242'; run;
 data a2000\_243\_v2 ; set a2000\_243 ; jy='2000'; jul='243'; run;
 data a2000\_244\_v2 ; set a2000\_244 ; jy='2000'; jul='244'; run;
 data a2000\_245\_v2 ; set a2000\_245 ; jy='2000'; jul='245'; run;
 data a2000\_246\_v2 ; set a2000\_246 ; jy='2000'; jul='246'; run;
 data a2000\_247\_v2 ; set a2000\_247 ; jy='2000'; jul='247'; run;
 data a2000\_248\_v2 ; set a2000\_248 ; jy='2000'; jul='248'; run;
 data a2000\_249\_v2 ; set a2000\_249 ; jy='2000'; jul='249'; run;
 data a2000\_250\_v2 ; set a2000\_250 ; jy='2000'; jul='250'; run;
 data a2000\_251\_v2 ; set a2000\_251 ; jy='2000'; jul='251'; run;
 data a2000\_252\_v2 ; set a2000\_252 ; jy='2000'; jul='252'; run;
 data a2000\_253\_v2 ; set a2000\_253 ; jy='2000'; jul='253'; run;
 data a2000\_254\_v2 ; set a2000\_254 ; jy='2000'; jul='254'; run;
 data a2000\_255\_v2 ; set a2000\_255 ; jy='2000'; jul='255'; run;
 data a2000\_256\_v2 ; set a2000\_256 ; jy='2000'; jul='256'; run;
 data a2000\_257\_v2 ; set a2000\_257 ; jy='2000'; jul='257'; run;
 data a2000\_258\_v2 ; set a2000\_258 ; jy='2000'; jul='258'; run;
 data a2000\_259\_v2 ; set a2000\_259 ; jy='2000'; jul='259'; run;
 data a2000\_260\_v2 ; set a2000\_260 ; jy='2000'; jul='260'; run;
 data a2000\_261\_v2 ; set a2000\_261 ; jy='2000'; jul='261'; run;
 data a2000\_262\_v2 ; set a2000\_262 ; jy='2000'; jul='262'; run;
 data a2000\_263\_v2 ; set a2000\_263 ; jy='2000'; jul='263'; run;
 data a2000\_264\_v2 ; set a2000\_264 ; jy='2000'; jul='264'; run;
 data a2000\_265\_v2 ; set a2000\_265 ; jy='2000'; jul='265'; run;
 data a2000\_266\_v2 ; set a2000\_266 ; jy='2000'; jul='266'; run;
 data a2000\_267\_v2 ; set a2000\_267 ; jy='2000'; jul='267'; run;
 data a2000\_268\_v2 ; set a2000\_268 ; jy='2000'; jul='268'; run;
 data a2000\_269\_v2 ; set a2000\_269 ; jy='2000'; jul='269'; run;
 data a2000\_270\_v2 ; set a2000\_270 ; jy='2000'; jul='270'; run;
 data a2000\_271\_v2 ; set a2000\_271 ; jy='2000'; jul='271'; run;
 data a2000\_272\_v2 ; set a2000\_272 ; jy='2000'; jul='272'; run;
 data a2000\_273\_v2 ; set a2000\_273 ; jy='2000'; jul='273'; run;
 data a2000\_274\_v2 ; set a2000\_274 ; jy='2000'; jul='274'; run;
 data a2000\_275\_v2 ; set a2000\_275 ; jy='2000'; jul='275'; run;
 data a2000\_276\_v2 ; set a2000\_276 ; jy='2000'; jul='276'; run;
 data a2000\_277\_v2 ; set a2000\_277 ; jy='2000'; jul='277'; run;
 data a2000\_278\_v2 ; set a2000\_278 ; jy='2000'; jul='278'; run;
 data a2000\_279\_v2 ; set a2000\_279 ; jy='2000'; jul='279'; run;
 data a2000\_280\_v2 ; set a2000\_280 ; jy='2000'; jul='280'; run;
 data a2000\_281\_v2 ; set a2000\_281 ; jy='2000'; jul='281'; run;
 data a2000\_282\_v2 ; set a2000\_282 ; jy='2000'; jul='282'; run;
 data a2000\_283\_v2 ; set a2000\_283 ; jy='2000'; jul='283'; run;
 data a2000\_284\_v2 ; set a2000\_284 ; jy='2000'; jul='284'; run;
 data a2000\_285\_v2 ; set a2000\_285 ; jy='2000'; jul='285'; run;
 data a2000\_286\_v2 ; set a2000\_286 ; jy='2000'; jul='286'; run;
 data a2000\_287\_v2 ; set a2000\_287 ; jy='2000'; jul='287'; run;
 data a2000\_288\_v2 ; set a2000\_288 ; jy='2000'; jul='288'; run;
 data a2000\_289\_v2 ; set a2000\_289 ; jy='2000'; jul='289'; run;
 data a2000\_290\_v2 ; set a2000\_290 ; jy='2000'; jul='290'; run;
 data a2000\_291\_v2 ; set a2000\_291 ; jy='2000'; jul='291'; run;
 data a2000\_292\_v2 ; set a2000\_292 ; jy='2000'; jul='292'; run;
 data a2000\_293\_v2 ; set a2000\_293 ; jy='2000'; jul='293'; run;
 data a2000\_294\_v2 ; set a2000\_294 ; jy='2000'; jul='294'; run;
 data a2000\_295\_v2 ; set a2000\_295 ; jy='2000'; jul='295'; run;
 data a2000\_296\_v2 ; set a2000\_296 ; jy='2000'; jul='296'; run;
 data a2000\_297\_v2 ; set a2000\_297 ; jy='2000'; jul='297'; run;
 data a2000\_298\_v2 ; set a2000\_298 ; jy='2000'; jul='298'; run;
 data a2000\_299\_v2 ; set a2000\_299 ; jy='2000'; jul='299'; run;
 data a2000\_300\_v2 ; set a2000\_300 ; jy='2000'; jul='300'; run;
 data a2000\_301\_v2 ; set a2000\_301 ; jy='2000'; jul='301'; run;
 data a2000\_302\_v2 ; set a2000\_302 ; jy='2000'; jul='302'; run;
 data a2000\_303\_v2 ; set a2000\_303 ; jy='2000'; jul='303'; run;
 data a2000\_304\_v2 ; set a2000\_304 ; jy='2000'; jul='304'; run;
 data a2000\_305\_v2 ; set a2000\_305 ; jy='2000'; jul='305'; run;
 data a2000\_306\_v2 ; set a2000\_306 ; jy='2000'; jul='306'; run;
 data a2000\_307\_v2 ; set a2000\_307 ; jy='2000'; jul='307'; run;
 data a2000\_308\_v2 ; set a2000\_308 ; jy='2000'; jul='308'; run;
 data a2000\_309\_v2 ; set a2000\_309 ; jy='2000'; jul='309'; run;
 data a2000\_310\_v2 ; set a2000\_310 ; jy='2000'; jul='310'; run;
 data a2000\_311\_v2 ; set a2000\_311 ; jy='2000'; jul='311'; run;
 data a2000\_312\_v2 ; set a2000\_312 ; jy='2000'; jul='312'; run;
 data a2000\_313\_v2 ; set a2000\_313 ; jy='2000'; jul='313'; run;
 data a2000\_314\_v2 ; set a2000\_314 ; jy='2000'; jul='314'; run;
 data a2000\_315\_v2 ; set a2000\_315 ; jy='2000'; jul='315'; run;
 data a2000\_316\_v2 ; set a2000\_316 ; jy='2000'; jul='316'; run;
 data a2000\_317\_v2 ; set a2000\_317 ; jy='2000'; jul='317'; run;
 data a2000\_318\_v2 ; set a2000\_318 ; jy='2000'; jul='318'; run;
 data a2000\_319\_v2 ; set a2000\_319 ; jy='2000'; jul='319'; run;
 data a2000\_320\_v2 ; set a2000\_320 ; jy='2000'; jul='320'; run;
 data a2000\_321\_v2 ; set a2000\_321 ; jy='2000'; jul='321'; run;
 data a2000\_322\_v2 ; set a2000\_322 ; jy='2000'; jul='322'; run;
 data a2000\_323\_v2 ; set a2000\_323 ; jy='2000'; jul='323'; run;
 data a2000\_324\_v2 ; set a2000\_324 ; jy='2000'; jul='324'; run;
 data a2000\_325\_v2 ; set a2000\_325 ; jy='2000'; jul='325'; run;
 data a2000\_326\_v2 ; set a2000\_326 ; jy='2000'; jul='326'; run;
 data a2000\_327\_v2 ; set a2000\_327 ; jy='2000'; jul='327'; run;
 data a2000\_328\_v2 ; set a2000\_328 ; jy='2000'; jul='328'; run;
 data a2000\_329\_v2 ; set a2000\_329 ; jy='2000'; jul='329'; run;
 data a2000\_330\_v2 ; set a2000\_330 ; jy='2000'; jul='330'; run;
 data a2000\_331\_v2 ; set a2000\_331 ; jy='2000'; jul='331'; run;
 data a2000\_332\_v2 ; set a2000\_332 ; jy='2000'; jul='332'; run;
 data a2000\_333\_v2 ; set a2000\_333 ; jy='2000'; jul='333'; run;
 data a2000\_334\_v2 ; set a2000\_334 ; jy='2000'; jul='334'; run;
 data a2000\_335\_v2 ; set a2000\_335 ; jy='2000'; jul='335'; run;
 data a2000\_336\_v2 ; set a2000\_336 ; jy='2000'; jul='336'; run;
 data a2000\_337\_v2 ; set a2000\_337 ; jy='2000'; jul='337'; run;
 data a2000\_338\_v2 ; set a2000\_338 ; jy='2000'; jul='338'; run;
 data a2000\_339\_v2 ; set a2000\_339 ; jy='2000'; jul='339'; run;
 data a2000\_340\_v2 ; set a2000\_340 ; jy='2000'; jul='340'; run;
 data a2000\_341\_v2 ; set a2000\_341 ; jy='2000'; jul='341'; run;
 data a2000\_342\_v2 ; set a2000\_342 ; jy='2000'; jul='342'; run;
 data a2000\_343\_v2 ; set a2000\_343 ; jy='2000'; jul='343'; run;
 data a2000\_344\_v2 ; set a2000\_344 ; jy='2000'; jul='344'; run;
 data a2000\_345\_v2 ; set a2000\_345 ; jy='2000'; jul='345'; run;
 data a2000\_346\_v2 ; set a2000\_346 ; jy='2000'; jul='346'; run;
 data a2000\_347\_v2 ; set a2000\_347 ; jy='2000'; jul='347'; run;
 data a2000\_348\_v2 ; set a2000\_348 ; jy='2000'; jul='348'; run;
 data a2000\_349\_v2 ; set a2000\_349 ; jy='2000'; jul='349'; run;
 data a2000\_350\_v2 ; set a2000\_350 ; jy='2000'; jul='350'; run;
 data a2000\_351\_v2 ; set a2000\_351 ; jy='2000'; jul='351'; run;
 data a2000\_352\_v2 ; set a2000\_352 ; jy='2000'; jul='352'; run;
 data a2000\_353\_v2 ; set a2000\_353 ; jy='2000'; jul='353'; run;
 data a2000\_354\_v2 ; set a2000\_354 ; jy='2000'; jul='354'; run;
 data a2000\_355\_v2 ; set a2000\_355 ; jy='2000'; jul='355'; run;
 data a2000\_356\_v2 ; set a2000\_356 ; jy='2000'; jul='356'; run;
 data a2000\_357\_v2 ; set a2000\_357 ; jy='2000'; jul='357'; run;
 data a2000\_358\_v2 ; set a2000\_358 ; jy='2000'; jul='358'; run;
 data a2000\_359\_v2 ; set a2000\_359 ; jy='2000'; jul='359'; run;
 data a2000\_360\_v2 ; set a2000\_360 ; jy='2000'; jul='360'; run;
 data a2000\_361\_v2 ; set a2000\_361 ; jy='2000'; jul='361'; run;
 data a2000\_362\_v2 ; set a2000\_362 ; jy='2000'; jul='362'; run;
 data a2000\_363\_v2 ; set a2000\_363 ; jy='2000'; jul='363'; run;
 data a2000\_364\_v2 ; set a2000\_364 ; jy='2000'; jul='364'; run;

 /*merge ino 1 file*/
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_001\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_002\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_003\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_004\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_005\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_006\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_007\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_008\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_009\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_010\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_011\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_012\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_013\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_014\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_015\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_016\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_017\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_018\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_019\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_020\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_021\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_022\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_023\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_024\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_025\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_026\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_027\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_028\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_029\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_030\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_031\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_032\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_033\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_034\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_035\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_036\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_037\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_038\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_039\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_040\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_041\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_042\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_043\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_044\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_045\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_046\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_047\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_048\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_049\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_050\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_051\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_052\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_053\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_054\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_055\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_056\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_057\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_058\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_059\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_060\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_061\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_062\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_063\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_064\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_065\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_066\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_067\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_068\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_069\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_070\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_071\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_072\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_073\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_074\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_075\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_076\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_077\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_078\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_079\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_080\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_081\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_082\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_083\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_084\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_085\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_086\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_087\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_088\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_089\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_090\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_091\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_092\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_093\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_094\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_095\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_096\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_097\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_098\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_099\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_100\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_101\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_102\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_103\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_104\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_105\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_106\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_107\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_108\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_109\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_110\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_111\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_112\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_113\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_114\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_115\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_116\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_117\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_118\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_119\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_120\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_121\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_122\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_123\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_124\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_125\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_126\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_127\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_128\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_129\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_130\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_131\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_132\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_133\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_134\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_135\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_136\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_137\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_138\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_139\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_140\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_141\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_142\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_143\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_144\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_145\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_146\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_147\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_148\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_149\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_150\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_151\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_152\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_153\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_154\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_155\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_156\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_157\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_158\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_159\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_160\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_161\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_162\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_163\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_164\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_165\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_166\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_167\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_168\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_169\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_170\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_171\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_172\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_173\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_174\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_175\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_176\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_177\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_178\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_179\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_180\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_181\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_182\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_183\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_184\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_185\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_186\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_187\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_188\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_189\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_190\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_191\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_192\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_193\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_194\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_195\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_196\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_197\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_198\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_199\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_200\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_201\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_202\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_203\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_204\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_205\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_206\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_207\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_208\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_209\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_210\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_211\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_212\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_213\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_214\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_215\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_216\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_217\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_218\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_219\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_220\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_221\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_222\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_223\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_224\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_225\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_226\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_227\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_228\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_229\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_230\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_231\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_232\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_233\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_234\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_235\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_236\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_237\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_238\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_239\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_240\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_241\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_242\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_243\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_244\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_245\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_246\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_247\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_248\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_249\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_250\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_251\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_252\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_253\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_254\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_255\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_256\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_257\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_258\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_259\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_260\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_261\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_262\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_263\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_264\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_265\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_266\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_267\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_268\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_269\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_270\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_271\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_272\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_273\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_274\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_275\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_276\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_277\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_278\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_279\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_280\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_281\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_282\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_283\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_284\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_285\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_286\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_287\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_288\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_289\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_290\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_291\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_292\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_293\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_294\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_295\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_296\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_297\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_298\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_299\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_300\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_301\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_302\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_303\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_304\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_305\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_306\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_307\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_308\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_309\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_310\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_311\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_312\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_313\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_314\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_315\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_316\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_317\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_318\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_319\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_320\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_321\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_322\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_323\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_324\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_325\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_326\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_327\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_328\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_329\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_330\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_331\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_332\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_333\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_334\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_335\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_336\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_337\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_338\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_339\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_340\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_341\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_342\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_343\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_344\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_345\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_346\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_347\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_348\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_349\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_350\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_351\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_352\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_353\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_354\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_355\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_356\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_357\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_358\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_359\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_360\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_361\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_362\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_363\_v2;RUN;
 PROC APPEND BASE=Mod2\_2000all DATA=a2000\_364\_v2;RUN;
 data Mod2\_2000allv2;
 set Mod2\_2000all;
 juldate=compress(jy||jul);
 run;
 /*Format the julian dates into real dates*/
 data Mod2\_2000allv3 ;
 set Mod2\_2000allv2;
 newjul= input(juldate,julian7.);
 date=newjul;
 format DATE mmddyy8.;
 run;

*** subset by a specific date range

use this as an example:


data nas (where=(date>="01MAR2000"D )) ;;
set nas.nas;
run;

 another example:
 data Fncdc (where=(date>="01JAN2003"D and date<="31DEC2003"D )) ;
 set ncdc\_v2;
 run;

*** create a series of time

**

data seriesj;
 input Date date9. Value;
 format Date date9.;
 cards;
 01jan2000 1
 31dec2008 1
 run;

*** subset by the diffrance between 2 dates

here is an example of subsetting the data so that only dates that have a
smaller difference then 365 days are left
 **

data nas\_add\_moved;
 set nas\_add;
 where addenddate-date<=*365*;
 *run*;

*** expand a time series/add a long list of dates

use this code:
 **

data OUTDATA;
 set INDATA;
 by id;
 retain date;
 if first.id then do;
 date=mdy(*12*,*31*,*1999*);
 do while (date <= mdy(*9*,*30*,*2010*));
 date=date+*1*;
 output;
 end;
 end;
 format date mmddyy10.;
 *run*;

*** subtract days from date

use normal math operators:

 *data* bw19;
 set bw18;
 ddate=date-*7*;
 format dDATE mmddyy8.;
 *run*;

*** create a full date range for a dataset

use this code:

data casesd;
 set cases;
 by aid\_ct;
 retain date;
 if first.aid\_ct then do;
 date=mdy(03,1,2000);
 do while (date <= mdy(12,31,2008));
 /*do while (date <= mdy(3,31,1999));*/
 /*hrint = 0;
 do while (hrint < 24);
 output;
 hrint = hrint+1;
 end;*/
 output;
 date=date+1;
 end;
 end;
 format date mmddyy10.;
 run;
 where:
 aid\_ct-is the variable on which each date range will be expanded
 03,1,2000-is the start date of the range
 12,31,2008-is the end date of the range

*** Time

**** create a time variable from hour, minute and seconds

To create a time variable from hour, minute and seconds variables use
the 'hms' function
 Note: if you don't have a second variable just create a empty one with
Zeroes (see below example)
 **

data XX;
 set YY;
 seconds\_utc=*00*;
 date=mdy(month\_utc,day\_utc,year\_utc);
 format date date9.;
 time=hms(hour\_utc,minute\_utc,seconds\_utc);
 format time time8.;
 *run*;

**** convert from GMT/UTC to EST etc

use the following code:
 data XX;
 set YY;
 *** COMBINE GMT DATE AND TIME INTO A DATETIME VARIABLE ***;
 gmt\_datetime=dhms(date,0,0,time);
 *** CONVERT DATETIME VARIABLE FROM GMT TO EST ***;
 est\_datetime=gmt\_datetime - 5*60*60;
 *** FOR EST - SPLIT OUT THE DATE AND TIME ***;
 est=timepart(est\_datetime);
 est\_date=datepart(est\_datetime);
 *** DROP UNNEEDED VARIABLES ***;
 drop gmt\_datetime est\_datetime;
 format est time5. est\_date mmddyy10.;
 run;

*** Snippets
**** Create a series of dates with associated ID
#+begin_src sas

/*deviations from mean*/

data seriesj;
 input date date9. value;
 cards;
01jan2000 1
31dec2008 1
;
run;

%macro year;

%do year = 2000 %to 2008;


proc expand data = seriesj out=seriesj to=day method=step;
  convert Value  = daily_Value;
  id date;
run;

data seriesj&year(drop = year daily_Value);
 set seriesj;
  year = year(date);
 if year = &year;
 if date = "29Feb&year"d then delete;
 format date date9.;
run;

data seriesj&year;
 set seriesj&year;
 day_id = _N_;
run;

%end;

%mend;

%year;


data
/*creates the completed time series for above range*/
/*the output file is 'daily'*/
data daily;
 set daily;
  day_id = _n_ ;
run;


data seriesall;
set Seriesj2000 Seriesj2001 Seriesj2002 Seriesj2003 Seriesj2004 Seriesj2005 Seriesj2006 Seriesj2007 Seriesj2008;
run;

#+end_src

** Transformations

*** center data

Grand mean centering
 Instead of centering a variable around a value that you select, you may
want to center it around its mean. This is known as grand mean
centering. There are at least three ways that you can do this. Perhaps
the most straight-forward way is to get the mean of each variable that
you wan to center and subtract that value from the variable in a data
step. This is simple if you only need to center a few variables.
 proc means data = test mean;
 var score1 score2;
 run;
 Variable Mean
 ------------------------
 score1 43.9333333
 score2 34.5333333
 ------------------------
 data grand;
 set test;
 grmscore1 = score1 - 43.93;
 grmscore2 = score2 - 34.53;
 run;

*** Log transform

to run a log transform on a specific variable in a specific dataset
issue the command log().
 in example:
 data merg.step5\_2001;
  set merg.step4\_2001;
 pm\_mean = log ( MFVALUE\_mean\_1 );
 run;
 data new dataset created
 set Dataset based on
 pm\_mean Name of the new log transformed variable
 log the command
 MFVALUE\_mean\_1 old variable the log transformation is based on


*** quadric

to transform a variable into a quadric term you multiple the variable by
itself.
 IE:
 Height*height

** if else

*** simple operations

to delete cases/rows/variables use the if then command for example:
 data "c:\sas\out\_file";
 set "c:\sas\source\_file";
 if variable = . then delete;
 run;
 for example in the harvard reg course:
 data "c:\sas\stroke";
 set "c:\sas\nh2fs";
 if stroke = . then delete;
 run;
 you can of course delete cases based on math expressions for example:
 libname t2005 'X:\2)PostDoc\Database\AOD\_NE\SAS\lib\final\Terra\2005\'
;
 DATA t2005.all\_clean;
 SET t2005.all;
 if aod < 0.0000001 then delete;
 if aod > 2 then delete;
 RUN;

*** complex example

data mergif.TBoth\_2000\_s3;
 set mergif.TBoth\_2000\_s2;
 if pmnew = . then pmnew=allpred;
 run;
 in the above example if the variables (pmnew) os missing (.) then fill
it with another variable (allpred)

*** if else example

example:
 if SowingTimi="TOS 1" then stime=1;
 if SowingTimi="TOS 2" then stime=2 ;
 else if SowingTimi ne "TOS 2" or SowingTimi ne "TOS 1" then stime=.;

*** create dichtomus variabkes

use this sample code:
 data times7;
 set times6;
 if med\_inc < 41043 then inc\_bin\_25 = 0;
 else inc\_bin\_25=1;
 if med\_inc < 50506 then inc\_bin\_m = 0;
 else inc\_bin\_m=1;
 if med\_inc < 58797 then inc\_bin\_75 = 0;
 else inc\_bin\_75=1;
 if Avg\_per\_mi < 3.04 then min\_bin\_25 = 0;
 else min\_bin\_25=1;
 if Avg\_per\_mi < 6.68 then min\_bin\_m = 0;
 else min\_bin\_m=1;
 if Avg\_per\_mi < 14.74 then min\_bin\_75 = 0;
 else min\_bin\_75=1;
 if Avg\_p\_A65 < 12.257 then age\_bin\_25 = 0;
 else age\_bin\_25=1;
 if Avg\_p\_A65 < 14.06 then age\_bin\_m = 0;
 else age\_bin\_m=1;
 if Avg\_p\_A65 < 15.99 then age\_bin\_75 = 0;
 else age\_bin\_75=1;
 if Avg\_pctcol < 20.45 then col\_bin\_25 = 0;
 else col\_bin\_25=1;
 if Avg\_pctcol < 26.40 then col\_bin\_m = 0;
 else col\_bin\_m=1;
 if Avg\_pctcol < 36.21 then col\_bin\_75 = 0;
 else col\_bin\_75=1;
 if Avg\_pctnoh < 10.31 then hs\_bin\_25 = 0;
 else hs\_bin\_25=1;
 if Avg\_pctnoh < 14.00 then hs\_bin\_m = 0;
 else hs\_bin\_m=1;
 if Avg\_pctnoh < 19.38 then hs\_bin\_75 = 0;
 else hs\_bin\_75=1;
 run;

** aggregate
*** simple aggregation

This is a sample aggregation code:

#+BEGIN_SRC sas
 proc summary nway data=T2000;
 class sitecode;
 var mfvalue;
 output out=new mean(mfvalue)=barpm;
 run;
#+END_SRC

where:
 class-what to class (aggregate by- break value)
 var -the variable to aggregate on
 new-the new file name
 mean=the type of aggreagation (by mean/sum/etc)
 barpm=name of the new aggregated variable

*** aggreagate different variables with different functions

#+begin_src sas

proc summary nway data=devt2;
class udate guid;
var fintemp date;
output out=devfin2 mean(fintemp)=devtemp min(date)=date;
run;

#+end_src

where:
 class-what to class (aggregate by- break value)
 var -the variable to aggregate on
 new-the new file name
 sum/mean/min etc =the type of aggreagation (by mean/sum/etc)
 name of the new aggregated variable

*** aggregate with proc means

you could use proc means to aggregate data as well

#+begin_src sas
proc *means* data=mod2OLD_2011 n mean ;
 var aod;
 class guid x y ;
 ods output summary=summary_all_old;
 *run*;
#+end_src

*** using nodup key

you can also aggregate bu nudup key, which is useful for character
variables
#+begin_src sas
proc sort data = nasexpdays_ap_met nodupkey out=DATAOUTPUTNAME;
by xinkm yinkm;
run ;
#+end_src

** lags
*** create time lags by date and location (grid id)

use the following example :
 data poll2;
 set poll;
 by guid date;
 lag001=lag(PMNEW); if first.guid then lag001=.;
 run;
 data poll2;
 set poll2;
 by guid date;
 lag002=lag(lag001); if first.guid then lag002=.;
 run;
 *where:*
 *guid-is the grid/case you want to lag for
 pmnew-is the lag variable (in the above PM 2.5 readings)
 lag001-is the first lag (a 1 day lag)
 lag002-is the second day lag (a 2 day lag)*

*** calculate means of lags

Example:
 data stroke_v2;
 set stroke;
 lag0=pmnew;
 lag0_1=MEAN(pmnew,pm_lag1);
 lag1_2=MEAN(pm_lag1, pm_lag2);
 lag0_2=MEAN(pmnew,pm_lag1, pm_lag2);
 run;

*** macro to create a lag

%macro makelags(dir,fname,pol);
 data &pol; set &dir..&fname;
 &pol._l0=&pol;
 %local i;
 %do i=0 %to 240;
 &pol._l%eval(&i+1)=lag1(&pol._l&i);
 %end;
 &pol.ma1 = mean(&pol._l0,&pol._l1);
 *&pol.ma3 = mean(&pol._l0,&pol._l1,&pol._l2);
 &pol.ma2 = mean(of &pol._l0 - &pol._l3);
 *&pol.ma5 = mean(of &pol._l0 - &pol._l4);
 &pol.ma3 = mean(of &pol._l0 - &pol._l5);
 &pol.ma4 = mean(of &pol._l0 - &pol._l7);
 &pol.ma5 = mean(of &pol._l0 - &pol._l9);
 &pol.ma6 = mean(of &pol._l0 - &pol._l11);
 &pol.ma12 = mean(of &pol._l0 - &pol._l23);
 &pol.ma24 = mean(of &pol._l0 - &pol._l47);
 &pol.ma48 = mean(of &pol._l0 - &pol._l95);
 &pol.ma72 = mean(of &pol._l0 - &pol._l143);
 &pol.ma96 = mean(of &pol._l0 - &pol._l191);
 &pol.ma120 = mean(of &pol._l0 - &pol._l239);
 keep datetime date hour &pol.ma2 - &pol.ma120
 &pol._l48 &pol._l46 &pol._l44 &pol._l42 &pol._l40
 &pol._l38 &pol._l36 &pol._l34 &pol._l32 &pol._l30
 &pol._l28 &pol._l26 &pol._l24 &pol._l22 &pol._l20
 &pol._l18 &pol._l16 &pol._l14 &pol._l12 &pol._l10
 &pol._l8 &pol._l6 &pol._l4 &pol._l2;
 run;
 %mend;

 %makelags(uno,apmet30,pm25new);
 %makelags(uno,apmet30,bc);

** conversions

*** convert Fahrenheit to Celsius

 *To convert Fahrenheit to Celsius:*
 Tc=(5/9)*(Tf-32)
 Tc=temperature in degrees Celsius Tf=temperature in degrees
Fahrenheit
 * means multiply
 *Now, to convert from Celsius to Fahrenheit :*
 Tf=(9/5)*Tc+32
 Tc=temperature in degrees Celsius Tf=temperature in degrees
Fahrenheit

*** create guid (drid id ) from X and Y (long and lat)

/*copy x and y coordinantes from numeric to character (text) variables*/
 data resultsv3 ;
 set resultsv2 ;
 xnym=put(Long_aod,6.2);
 ynym=put(Lat_aod,6.2);
 xnymx = xnym*-100;
 ynymx = ynym*100;
 guid=compress(xnymx||ynymx);
 run;

 /*convert if from text to numeric*/
 data resultsv4 ;
 set resultsv3 ;
 drop xnymx ynymx xnym ynym;
 guid2=input(guid, 8.);
 drop guid;
 run;
 data resultsv5;
 set resultsv4;
 guid=guid2;
 drop guid2;
 run;

** transpose

*** proc transpose

[[./sas_files/attach/sas_transpose.pdf][Attachment #05
(sas_transpose.pdf)]]
 proc transpose data = Sum_s1_mean_r out=Sum_s1_mean_r;
 by date;
 id Effect;
 run;
 *(see attachment for more details)*

*** add a prefix to variables during transpose

proc transpose data = Solutionf_s1 prefix=fix_ out=transp_3_s1;
 id Effect;
 run;
 fix_- the prefix to be appended to each variable name

*** simple transpose

 proc transpose data = PM_All_complete_full_v2 out=pmtranspose
prefix=st_;
 by date;
 id sitecode;
 run;
 data pmtranspose ;
 set pmtranspose;
  where _NAME_ = "PM25__F";
 run;
 id=the number of columns you create will take the name out of the
sitecode
 where _NAME_ = "PM25__F";- defines which variables to leave
otherwise all variables from datasets would be kept
 [[./sas_files/img/Image_1ePLw3ytwpb8w4YycvsR8w_0001.png]]

** split datasets

*** split for CV

#+BEGIN_SRC SAS
data split_s1;
 retain seed 2453;
 set out2001_v3;
 if ranuni(seed) < .9 then selected = 1;
 else selected = 0;
 run;
 data split90_s1;
 set split_s1;
 if selected = 1;
 run;
 data split10_s1;
 set split_s1;
 if selected = 0;
 run;
#+END_SRC


 where:
 .9- indicates a 90% to 10% slipt
 2453-indicates a seed random number- you need to change that seed
number each iteration if you want a different random number

** info

*** get a list (table) of all or selected variables

to get a list (table) of all or selected variables:
 use first proc contents to get a table of all variables
 PROC CONTENTS DATA = Mod2pred2004_v5
 OUT=VAR_NAMES(KEEP = NAME) NOPRINT;
 RUN;
 then if needed use the where statement to select variables based on
text in the var names:
 DATA PARSE;
 SET VAR_NAMES;
 WHERE (SUBSTR(NAME, 1,1) IN ('X''Y' ));
 RUN;
 where:
 'Y'- is the letter you are looking for in the var name

** counts

*** add counts

/*sort by the shortest distance in each sitecode first and give it a
count*/
 proc sort data = Res_aod_pm_met; by sitecode distance; run;
 data Res_aod_pm_met;
 set Res_aod_pm_met;
 count + 1;
 by Sitecode;
 if first.sitecode then count = 1;
 run;

** expand

*** use proc expand to fill in unavilable days prev/after avilable days

Many times a time series has gaps between two time points. For example,
the first ten observations of our example data set goes from 01/04/2001
to 01/18/2001. Proc expand offers many different methods for filling in
the gaps. In this example, we will use the "method=step" option to fill
the gaps with most the recent input value.
 proc expand data = in.sp500 out=daily to=day method=step;
 convert open = daily_open;
 id date;
 run;

*** duplicate/replicate cases

use this:
 data OUTDATA;
 set INPUDATA;
 do id = 0 to NUMBERNEEDED;
 output;
 end;
 run;
 IE:
 data b;
 set a;
 do id = 0 to 877;
 output;
 end;
 run;
 *where:* we want 877 replications of the data
 id is the id field

** rounding numbers
*** round command
use the round command:

#+begin_src sas
data WORK.lst2;
 set WORK.lst;
 nx = round(x,*0.01*);
 ny = round(y,*0.01*);
 run;
#+end_src

*** round numbers to common 4 digit format

#+begin_src sas
data gridx;
set grid ;
  format Lat_aod  16.4;
  format Long_aod 16.4;
run;
#+end_src

** character variables

*** change lenght of variable

*data* DATA;
 length VARNAME $ *6*;
 set DATA;
 *run*;
 where: the *6* is the new length
 *In example:*
 **

data bcold2;
 length AddIDNew $ *6*;
 set bcold;
 *run*;

* Statistics
** Descriptive Statistics
*** crosstabs

Crosstabs
 Below is how to get a crosstab ofprgtypebyses
 proc freq data='c:\sas\hs0';
 table prgtype*ses;
 run;
 the next example shows how to include a chi square test and how to get
the expected frequencies.
 proc freq data='c:\sas\hs0';
 table prgtype*ses / chisq expected;
 run;

*** Proc tabulate
Table of means using proc tabulate

The table above displays the information that we need and we could even make it easier to read by using value labels.  However, the only control over the layout of the table is the ordering of the classification variables.  For example we could change the position of female and ses in the output by switching their order in the class statement.  On the other had we could use proc tabulate which will give us the same information with the added benefit of being able to arrange the table in the most appropriate way.  Now lets try using proc tabulate to create a table with the same information as the one above.  The following table is a basic example that specifies one row variable (female), one column variable (ses), one analysis variable (write) and one summary statistic (mean).  Note that if we don't specify the mean as the summary statistic our table will contain the sum because it is the default summary statistic.

#+begin_src sas
proc tabulate data =hsb2;
  class ses female;
  var write;
  table female*mean,
        write*ses;
run;
#+end_src

*** proc means
**** proc means options
-common proc means options-
Statistical options that may be requested are: (default statistics are underlined.)
 N - Number of observations
 NMISS - Number of missing observations
 MEAN - Arithmetic average)
 STD - Standard Deviation
 MIN - Minimum (smallest)
 MAX - Maximum (largest)
 RANGE - Range
 SUM - Sum of observations
 VAR - Variance
 USS -- Uncorr. sum of squares
 CSS - Corr. sum of squares
 STDERR - Standard Error
 T - Student's t value for testing Ho: md = 0
 PRT - P-value associated with t-test above
 SUMWGT - Sum of the WEIGHT variable values
 MEDIAN -- 50th percentile
 P1 -- 1st percentile
 P5 - 5th percentile
 P10 -- 10th percentile
 P90 - 90th percentile
 P95 -- 95th percentile
 P99 - 99th percentile
 Q1 - 1st quartile
 Q3 - 3rd quartile
 QRANGE -- Quartile range
 Other commonly used options available in PROC MEANS include:
 DATA= Specify data set to use
 NOPRINT Do not print output
 MAXDEC=n Use n decimal places to print output
 Commonly used statements with PROC MEANS include:
 BY variable list -- Statistics are reported for groups in separate
tables
 CLASS variable list -- Statistics reported by groups in a single
table
 VAR variable list -- specifies which numeric variables to use
 OUTPUT OUT = datasetname -- statistics will be output to a SAS data
file
 FREQ variable - specifies a variable that represents a count of
observations

**** calculate quarentiles (proc means)
you can use proc means to calculate qurtiles:
 Proc means data = *DATANAME* n mean median (or p50) p25 p75;
 Var *VARNAMES*;
 Run;
 you can also add a class command:
 The class option allows you to break out subgroups from the data. This
is nice when you have a table with more than one group, and you want to
find stats on all the groups. For example, if you had a table with 2
columns:
 DayOfWeek Calls
 Monday 6
 Monday 7
 Tuesday 8
 Tuesday 9
 You can have:
 Proc means data=/*table name*/ n mean p25 p75;
 Class DayOfWeek;
 Var Calls;
 run;
 the output would be something like:
 DayofWeek Mean_Calls P25 P75
 Monday 6.5 6 7
 Tuesday 8.5 8 9
 Without the Class, the out is like this:
 Mean P25 P75
 7.5 6 9
**** output to dataset

#+begin_src sas
ods listing close;
proc means data=DATA1;
ods output summary=DATAOUT;
run;
ods listing;
#+end_src

**** Table using proc means

Lets say that we need to present a table of mean writing scores by socioeconomic status and gender.  Below we use proc means to create such a table.

#+begin_src sas

proc means data=hsb2 mean;
class female ses;
var write;
run;
#+end_src

*** Proc univariate
used to get a wide range of statistics on your data

#+begin_src sas
proc univariate data=XXX;
run;

/*you can also get statistics by a factor variable with the by statement*/

proc univariate data=XXX;
by site;
run;
#+end_src

*** proc boxplot

We can useproc boxplotto get side-by-side boxplots for the
variablewritebroken down by the levels ofprgtype; however, this
requires that we first sort the data usingproc sort.
 proc sort data='c:\sas\hs0';
 by prgtype;
 run;
 proc boxplot data='c:\sas\hs0';
 plot write*prgtype / boxstyle=schematic boxwidth=10;
 run;

*** proc corr

Correlations
 proc corris used to get correlations among variables. By
default,proc corruses pairwise deletion for missing observations. If
you use thenomissoption,proc corruses listwise deletion and omits
all observations with missing data on any of the named variables.
 proc corr data='c:\sas\hs0';
 var write read science;
 run;
 proc corr data='c:\sas\hs0' nomiss;
 var write read science;
 run;
 this will exclude the missing data (nomiss)
 We conclude withproc regshowing a simple regression
predictingwritefromreadalong with a scatterplot and regression line.
 proc reg data='c:\sas\hs0';
 model write=read;
 plot write*read ;
 run;

*** mean (proc mean)
*** ratios

[[./sas_files/attach/calcualte_lges_ratio_per_tract.sas][Attachment #06
(calcualte_lges_ratio_per_tract.sas)]]
 If you want to create ratios between a 0/1 variable use this code:
 **

proc *sort* data = bw_noces; by FIPS; ;*run*;
 ods trace on;
 *proc* *freq* data=bw_noces;
 table lges / list;
 by FIPS;
 ods output OneWayFreqs=ratio0002;
 where date>=*'01Jan2000'D* and date<=*'31Dec2002'D* ;
 *run*;
 ods trace off;
 *data* ratio0002v;
 set ratio0002;
 lbwprev=Percent/*100*;
 where lges=*1*;
 normbwprev=*1*-lbwprev;
 ratiodiff=lbwprev-normbwprev;
 keep fips lbwprev normbwprev ratiodiff;
 if fips=*.* then delete;
 *run*;
 *PROC* *EXPORT* DATA= ratio0002v
 OUTFILE=
"c:\Users\ekloog\Documents\$Doc\3.PostDoc\3.1.Projetcs\3.1.11.BirthW_NE\3.1.11.4.Work\Archive\ratio\ratio0002.dbf"
 DBMS=DBF REPLACE;
 *RUN*;
 the full script is attached with more options

*** frequnecies/precentages (proc freq)
**** a freq table by variable
#+BEGIN_SRC sas
proc freq data=all3;
 table brace ;
 where stroke=1;
 run;
#+END_SRC

**** create a freq table for 1 variable

#+begin_src sas
proc freq data=mods.Fintmpc_&year;
table guid / list;
 ods output onewayfreqs=list_&year;
run;

#+end_src

$Note:when using 1 variable use onewayfreq, if its more then 1 variable use the list command, see below section$

**** create a frequancy table by 2 variables (IE lat/long)
#+BEGIN_SRC sas
proc freq data=aodagg9;
 table glong*glat / list;
 ods output list=list;
 run;

proc sort data = list; by Frequency ;run;
#+END_SRC

**** output multiple tables in proc freq
you can also output different tables in the same command

#+begin_src sas
proc freq data=zinc ;
table crop / list;
table crop*cultivar / list;
run;
#+end_src

**** get frequencies by a variable

#+begin_src sas
proc sort data = zinc; by crop ;run;

proc freq data=zinc ;
table cultivar / list;
by crop;
run;

#+end_src

** Correlations

*** basics (proc corr)

proc corr data = ran5_s10;
 var MFValue pred;
 run;

*** add weight statement

proc corr data = ran5_s10;
 *weight normwt;*
 var MFValue pred;
 ods output PearsonCorr = PearsonCorr_s10;
 run;

*** export results to a table

*ods trace on;*
 proc corr data = ran5_s10;
 weight normwt;
 var MFValue pred;
 *ods output PearsonCorr = PearsonCorr_s10*;
 run;
 *ods trace off;*

** Nonparametric Tests of Group Differences

** t-tests

** ANOVA/MANOVA

*** ANOVA

**** Fit a Model

**** Look at Diagnostic Plots

**** Evaluate Model Effects

**** Multiple Comparisons

**** Visualizing Results

*** MANOVA

*** Assessing Classical Test Assumptions

** Regression
*** proc reg (linear regression)
#+begin_src sas
proc reg;
model yield=fert/solution;
ods output  ParameterEstimates =NAME ;
run;
#+end_src
    
*** proc glm for linear regression
one can use proc glm as well for linear regression

#+BEGIN_SRC SAS
proc glm;
model yield=fert/solution;
ods output  ParameterEstimates =NAME ;
run;
#+END_SRC
*** use the by

you can use the by to run the regression each time by a different
variable type IE:
 proc mixed data=zinc method=reml;
 class crop paircount cultivar ;
 model lzinc = CO water nitrolevel/ s ;
 random int / sub = paircount s;
 *by crop_type;*
 ods output solutionf=zincsol;
 run;
 where the regression ( a mixed model in the above example) is run for
each crop type seperatly
*** logistic regression
**** Basic logistic regression

#+begin_src sas
proc logistic data=Bw_diab  desc;
  class kess  MRN EDU_GROUP fips byob FIPS;
    model diab = pmnewmabirth  age_centered age_centered_sq cig_preg cig_pre med_income p_ospace gender
  hyper_other lungd  kess  MRN edu_group  byob sinetime costime temp_fmabirth FIPS ;
  run;
#+end_src
$Note-use the desc option to model the probability of 1 other wise it will be modelling 0$
**** proc logistic						  :CANCELLED:
Using the logit model:

Below we run the logistic regression model. To model 1s rather than
0s, we use the descending option. We do this because by default, proc
logistic models 0s rather than 1s, in this case that would mean
predicting the probability of not getting into graduate school
(admit=0) versus getting in (admit=1). Mathematically, the models are
equivalent, but conceptually, it probably makes more sense to model
the probability of getting into graduate school versus not getting
in. The class statement tells SAS that rank is a categorical
variable. The param=ref option after the slash requests dummy coding,
rather than the default effects coding, for the levels of rank. For
more information on dummy versus effects coding in proc logistic, see
our FAQ page: In PROC LOGISTIC why aren't the coefficients consistent
with the odds ratios?.

#+BEGIN_SRC sas
proc logistic data="c:\data\binary" descending;
  class rank / param=ref ;
  model admit = gre gpa rank;
OUTPUT OUT=PROB PREDICTED=PHAT;
run;
#+END_SRC

$NOTE:to get predicted- use the out=PROB and predicted commands in above code$

**** catagorical variables

Sas uses the highest number for the catagorical variables as the
reference catagory.
 Sometimes its better to split catagorical variables to dummy variables

*** find outliers

in SAS for simple regression modles run this code :
 proc reg data = out2000;
 model Pm25 = AOD;
 output out = Residual(keep=PM25 aod
 r lev cd dffit)
  rstudent=r h=lev cookd=cd dffits=dffit;
 run;
 quit;
 we are mainly intrested in the Studentized Residual without Current Obs
(*rstudent*)
 We should pay attention to studentized residuals that exceed +2 or -2,
and get even more concerned about residuals that exceed +2.5 or -2.5 and
even yet more concerned about residuals that exceed +3 or -3.
 you can there subset the data with a where statment:
 data Residual_2000_v2;
 set Residual_2000;
 where abs(r)>3;
 run;
 for more info look at:

[[http://www.ats.ucla.edu/stat/sas/webbooks/reg/chapter2/sasreg2.htm][http://www.ats.ucla.edu/stat/sas/webbooks/reg/chapter2/sasreg2.htm]]

** scale by IRQ

* Advanced Statistics

** Mixed models (proc mixed)
*** mixed model

the mixed model procedure is run by issuing the *proc mixed*command
 here is an example
 proc mixed data=t2005.t2005all_clean method=reml;
 class date_;
 model mfvalue = aod pop_den dist_ocean contour traf_den /s
*outpred=pdataA_2001v2*;
 random intercept aod / subject=date_ ;
 run;
 proc mixed tells sas that its runing a mixed model
 class is issued in order to create dummy variables (in this case date)
 model specifies the DV and IV's- in this case mfvalue (pm value) as the
DV and aod,pop density etc.. as all the IV's.
 / s (or / solution) *must*be added to the model in order to get the
beta, t and sig tables!
 random is where you define the intercept and slopes for each needed
variable (aod in this case). subject=date_ meand a random intercept for
each day
 *outpred=pdataA_2001v2*-the outputed table including the predictions
 proc mixed data = tst2 method=reml;
 class date;

 model MFVALUE = AOD / s outpred=pdataA_2001v2;
 random int AOD / sub = date s;
 run;

*** model options

*MODEL statement
*
 MODEL dependent = fixed effects / options Use . for interactions. Need
to define non-linear terms in DATA statement.
 Useful options:
 DDFM = satterthwaite, use Satterthwaite approximation for
 calculating degrees of freedom
 SOLUTION, output fixed effects estimates
 CL, give confidence intervals for fixed effect estimates
 *
 Random statement*
 Used to specify random effects/coefficients β , and form of variance
matrix G .
 RANDOM random effects / options
 Useful options:
 SOLUTION: print random effects solution
 G: print G matrix
 V: print V matrix
 GROUP = effect: estimate separate G matrix for
 each group
 SUBJECT = blocking effect TYPE = covariance pattern: specify
 block diagonal form for G matrix (eg. for random coefficients
 model: SUBJECT=patient TYPE=UN)

*** get r2 for mixed model

you need to get the predicted values for all cases and then correlate
that with observed values , then squere root that to get the r2
 this is done by adding the predicted to the database using the
following command:
 proc mixed data=year.t2000all_clean;
 class date_;
 model mfvalue = aod pop_den dist_ocean contour traf_den /solution
outp=t2000_resp residual ;
 random intercept aod / subject=date_ ;
 run;
 outp in the solution section means it will output the residuals
(including the predicted) (outp is the conditional residuals vs outm-see
link) into a file named t2000_resp residual that is a copy of the orig
file with residuals, predicted etc..
 then run proc corr to get the results:
 proc corr data=work.t2000_resp ;
 var mfvalue pred;
 run;
 proc corr the correlation command
 var which varibales
 mfvalue pred the observed (in this case mfvalue-pm2.5 values) and the
predicted
 you then get the results (in the red box bellow)
 [[./sas_files/img/Image_VE3vf2-XsB0gR9lr4UkeEQ_0001.png]]
 The root squere of the would give you the R2

*** mixed models with multiple random statemnets and weights

proc mixed data = mod1_T2001_90_s10_v3 method=reml;
 class reg_name zid date;
 weight normwt;
 model MFVALUE = AOD_X Temp_X t_avgs s_avgs st_avgs / s
outpred=pdata;
  random int AOD_X Temp_X / sub = date(reg_name) s;
 random x1--x18 / sub = zid s;
 ods output SolutionF = SolutionF_s10;
 ods output SolutionR = SolutionR_s10;
 run;
 proc mixed tells sas that its runing a mixed model
 class is issued in order to create dummy variables (in this case date)
 model specifies the DV and IV's- in this case mfvalue (pm value) as the
DV and aod etc.. as all the IV's.
 /solution (or /s) *must be added to the model* in order to get the
beta, t and sig tables!
 random is where you define the intercept and slopes for each needed
variable .
 subject (or 'sub') =date means a random intercept for each day
 (reg_name) means that we are nesting regions within each date
 ods output SolutionF -to extract the fixed effects
 ods output SolutionFR- to extract the random effects

*** calcualte predictions manually

data NOMISS_v4_s1;
 set NOMISS_v3_s1;
 pred = fix_intercept + AOD_X*fix_AOD_X + Temp_X*fix_Temp_X +
t_avgs*fix_t_avgs +
 s_avgs*fix_s_avgs + st_avgs*fix_st_avgs +
 + X1*Ran_X1
 + X2*Ran_X2
 + X3*Ran_X3
 + X4*Ran_X4
 + X5*Ran_X5
 + X6*Ran_X6
 + X7*Ran_X7
 + X8*Ran_X8
 + X9*Ran_X9
 + X10*Ran_X10
 + X11*Ran_X11
 + X12*Ran_X12
 + X13*Ran_X13
 + X14*Ran_X14
 + X15*Ran_X15
 + X16*Ran_X16
 + X17*Ran_X17
 + X18*Ran_X18 + AOD_X*AOD_reg + temp_X*Temp_reg + int_reg;
 run;

*** output solutions to a table

use the ods function
 IE:
 proc mixed data=zinc method=reml;
 class crop paircount cultivar ;
 model lzinc = CO water nitrolevel/ s ;
 random int / sub = paircount s;
 by crop_type;
 *ods output solutionf=zincsol;*
 run;
 where *solutionf is the part to output (here fixed solution but can be
solutionr for random etc..)
 zincsol is the output table name*

*** get confidance intervals

use the *cl* option in the model line:
 proc mixed data = bw6_fges method=reml covtest;
 class APNCU MRN EDU_GROUP TRACT;
 model BIRTHW = pmnewmamonth age_centered age_centered_sq GES_AGE
CIG_PREG CIG_PRE mean_income per_open_rec
 GENDER PREV_400 DIAB HYPER LUNGD DIABETESPR PREVPRE EDU_GROUP APNCU
MRN adtmean / s *cl*outpred=OUTFILE;
 random int / sub = TRACT s;
 ods output SolutionF = FullGESmixed30day;
 run;

*** glimix (logistic mixed model)

This is the base model:
 proc glimmix data=bw_noces ;
 class kotck byob FIPS;
 model lges (event= "*1*")= pmnewmamonth kotck MRN edu_group
m_care mstat FRN byob /s dist=*binary* link=logit *or* ;
 random intercept / subject=FIPS ;
 ods output oddsratios=oddratio ;
 run;

 event= "*1*"- the reference DV category
 binary-distribuation type
 or-odds ratio

*** outliers and infuential data points

[[./sas_files/attach/inf_data_points_mixed.pdf][Attachment #07
(inf_data_points_mixed.pdf)]]
 Attached is a paper on influential data points in mixed models
 here is the code chunk:
 ods html;
 ods graphics off;
 proc mixed data=pr;
 class Person Gender;
 model y = Gender Age Gender*Age /
 influence(iter=5 effect=Person est);
 repeated / type=ar(1) subject=Person;
 run;
 ods graphics off;
 ods html close;

** Nlmixed
*** base
this is used as an alternative for proc glimix since it uses a different
algorithem then glimex which uses glmPQL
 to run issue this:
 proc nlmixed data=bw_noces_dummy;
 parms
 s2u = 0.01754
 b0 = -0.9707
 b1 = 0.01086
 b2 =-0.01885
 b3 =0.001301
 b4 = 0.02253
 b5 =0.001887
 b6 = -0.1670
 b7= -0.7701
 b8 = 0.3301
 b9 = 0.2557
 b10 = 0.7082
 b11 =-0.00130
 b12 = 1.3045
 b13 =-0.00135
 b14 = -0.1884
 b15 = 0.2171
 b16 = -1.4156
 b17 = -1.1828
 b18 = -1.1871
 b19 = -0.7912
 b20 =-0.07072
 b21 =-0.06486
 b22 =-0.05904
 b23 =-0.01041
 b24 = 0.03189
 b25 = 0.04448
 b26 = 0.05976
 b27 = 0.07998 ;

 xb = b0 + u + pmnewmabirth*b1+age_centered*b2+age_centered_sq*b3+
cig_preg*b4+ cig_pre*b5+ gender*b6+ prev_400*b7+
 diab*b8+ lungd*b9 + diab_other*b10+ methnic*b11+
prevpret*b12+parity*b13+ MRN_0*b14+
 MRN_1*b15+kess_1*b16+kess_2*b17+ kess_3*b18+kess_4*b19+
byob_2000*b20+ byob_2001*b21+
 byob_2002*b22+ byob_2003*b23+byob_2004*b24+ byob_2005*b25+
byob_2006*b26+ byob_2007*b27;

 p = exp(xb)/(1+exp(xb));
 model lges ~ binary(p);
 random u ~ normal(0,s2u) subject=fips;
 run;
 where:
 parms -are the paramaters you give from a previous model you've already
ran (proc glimix for example)
 s2u-is the random intercept
 b0-are the covariets (starting with the intercept b0 and then the first
Var b1 etc)
*** posion survival analaysis using nlmixed
You were both looking for the proc nlmixed code to do a survival as a poisson.
Here is the code for a poisson distribution. This need to be adjusted for your specific case.

In the case below (I was not doing a survival, just a poisson with a random intercept for id) ve was my outcome
You need to write the beginning values for the parameters:     parms b0=-10 b1=0 b2=0 b3=0  s=2.5 ;
You will have to write as many parameters as the variables in your model.
I am not sure if you can use the class statement for the categorical, I think you mught have to create the dummy yourself
For example:
#+begin_src sas
dow=weekday(date);
if dow=1 then wd1=1; else wd1=0;
if dow=2 then wd2=1; else wd2=0;
if dow=3 then wd3=1; else wd3=0;
if dow=4 then wd4=1; else wd4=0;
if dow=5 then wd5=1; else wd5=0;
if dow=6 then wd6=1; else wd6=0;

ods output ParameterEstimates=try ;*(keep= variable Estimate  StdErr);

proc nlmixed data=ve qpoints=5;
     parms b0=-10 b1=0 b2=0 b3=0  s=2.5 ;
     eta=b0 + b1*&pol + b2*date + b3*spring + u;
     m=exp(eta);
     model ve ~ poisson(m);
     random u~normal(0,s*s) subject= id;
     run;

#+end_src

* Plots/Graphs

** Graphical Parameters

*** title, Symbol and labels

to change symbols in SAS, add the symbol statement before the plot proc
 to add title add the title statement inside the plot prpc
 to add labels to the axis use the label statment

symbol1 v=dot h=*0.5* w=*0.5* c=green;

 proc gplot data = Compare_Pred;
 title "Pred Mod1 Simple vs New";
 plot pred_simple*pred_adv/grid;
  label pred_simple = "Simple";
 label pred_adv = "Advance";
 run;
 quit;
 where:
 symbol1-symbol type
 v=dot- symbol shape
 *c=green- symbol color
 title "Pred Mod1 Simple vs New" - title
 label pred_adv = "Advance" -label for the X axis*

** gplot

*** Simple scatter plot

For a simple scatter plot use this code:

proc gplot data=DATA;
 Plot VAR1*VAR2;
 run;
 quit;

** Histograms

proc univariate data=DATA;
 var VAR1 VAR2;
 histogram VAR1 VAR2;
 run;

* Output /ODS
** Basics
In essence, procedures send data to the Output Delivery System (ODS) which determines where the output should go and what it should look like. Two fundamental concepts of the ODS are destinations and templates. Different types of ODS output are called destinations. A template is a set of instructions telling ODS how to format your data.

If you don't specify a destination, your output will be sent, by default, to the listing, which is what you see in the Output window. Here are the major destinations:

LISTING    standard SAS output
OUTPUT    SAS output data set
HTML        Hypertext Markup Language
RTF            Rich Text Format
PRINTER   high resolution printer output
PS               Postscript
PCL            Printer Control Language
PDF            Portable Document Format
MARKUP   markup language including XML
DOCUMENT    output document
** ODS TRACE

It tells SAS to print information about output objects in the log. There are two ODS TRACE statements: one to turn on the trace, and one to turn it off.

#+begin_src sas
ODS TRACE ON;
the PROC steps you want to trace go here
RUN;
ODS TRACE OFF;
#+end_src


Example program:

#+begin_src sas
DATA tomato;
    INFILE 'v:\Tomato.txt' DSD;
    INPUT Name :$15. Color $ Days Weight;
/* Trace PROC MEANS */
ODS TRACE ON;
PROC MEANS DATA=tomato;
    BY Color;
RUN;
ODS TRACE OFF;

#+end_src

Because the above program contains a BY statement, PROC MEANS produces one output object for each BY group.

** ODS select
Once you know the names of the output objects, you can use an ODS
SELECT (or EXCLUDE) statement to choose just the output objects you
want. The general form is:

#+begin_src sas
The PROC step with the output objects you want to select
ODS SELECT output-object-list;
RUN;
#+end_src

The output-object-list is the name, label or path of one or more output objects separated by spaces. By default, an ODS SELECT statement lasts for only one PROC step, so by placing ODS SELECT after the PROC statement and before the RUN, you can capture the correct output. (Use the PERSIST option to make your selection last longer. See SAS Help.) ODS EXCLUDE works the same way except you list output objects that you don't want.
Example program (See the Tomato data above):

#+begin_src sas
PROC MEANS DATA=tomato;
    BY Color;
    TITLE 'Red Tomatoes';
ODS SELECT Means.ByGroup1.Summary;
RUN;
#+end_src

** ODS output

Sometimes you may want to put the results from a procedure into a SAS
data set so that you can merge them with another data set, create new
variables based on the results, or use the results in other
procedures. Some procedures have OUTPUT statements, or OUT= options,
allowing you to save the results as a data set. But with ODS you  can
save almost any part of procedure output as a SAS data set by sending
it to the OUTPUT destination. You use an 'ODS TRACE' to determine the
name of the output object you want and then use an ODS OUTPUT to send
that object to the OUTPUT destination. The genera form of ODS OUTPUT
is:

ODS OUTPUT output-object = new-data-set;

where output-object is the name, label or path of the piece of output you want to save. ODS OUTPUT opens a SAS data set and waits for the correct procedure output. The data set remains open until the end of a PROC step is reached. Because ODS OUTPUT executes immediately, it will apply to whatever PROC is currently being processed, or it will apply to the next PROC if there is not a current one. It is recommended that you put ODS OUTPUT after your PROC statement, and before the next PROC, DATA or RUN statement.
Example program :

#+begin_src sas
DATA tomato;
    INFILE 'v:\Tomato.txt' DSD;
    INPUT Name :$15. Color $ Days Weight;
PROC TABULATE DATA=tomato;
    CLASS Color;
    VAR Days Weight;
    TABLE Color ALL, (Days Weight) * MEAN;
    TITLE 'Standard TABULATE Output';
ODS OUTPUT Table = tabout;
RUN;
PROC PRINT DATA=tabout;
    TITLE 'OUTPUT SAS Data Set from TABULATE';
RUN;
#+end_src

** supress and restore printing

#+begin_src sas
/*PROC MEANS*/
/*also I show how to use "ods listing close" to supress printing and "ods listing"
to begin printing.  This is useful when the print out from the PROC is too much*/
ods listing close;
proc means data=sashelp.class;
ods output summary=john;
run;
ods listing;
#+end_src

** add title to output

to add a title to your output just add this in the commnds:
 proc corr;
 var X, Y;
 TITLE "NAME OF Title";
 run
 *make sure you use the " " and not '' in this case
*
 *This also works well inside macros*
 proc freq data= poll_&type._low ;
 table sex race2 / list;
 TITLE "poll_&type._low";
 run;

** output results of Regression (R2) to a table

use the following code:
 proc reg data = DATA;
 model VAR1 = VAR2 / clb;
 title "TITLE";
 ods output FitStatistics = NAME;
 run;
 quit;
 data NAME (keep = Type nValue2);
 set NAME;
 where label1="Root MSE";
 Type = "NAME";
 run;
 *example:
*
 proc reg data = ran_all_&year;
 model pm25_si = pred_si / clb;
 title "OA with sitcode-si";
 ods output FitStatistics = overall&year;
 run;
 quit;
 data overall&year(keep = Type nValue2);
 set overall&year;
 where label1="Root MSE";
 Type = "overall&year";
 run;

** output results to rtf (table)

if you want to output results of a stat test to a table you can use the
ods (output delivery system)
 example:
 *ods rtf;*
 proc corr data=pmstat_2000_s1_v7;
 TITLE 'cold season s1';
 var mfvalue pm_mod3;
 run;
 proc corr data=pmstat_2000_s1_v8;
 var mfvalue pm_mod3;
 TITLE 'warm season s1';
 run;
 *ods rtf close;*
 so you start with the ods command, run all the test you want to be
outputed and then end with the ods close command.

** get info on current model parameters

use the ods trace to get info on the model parts and parameters to
extract it later
 ods trace on;
 proc means data = Solutionr_s1 mean;
 class Effect date;
 var Estimate;
 ods output Summary = Sum_s1_mean_r;
 run;
 ods trace off;

** make the data non centered (start in the left)
add this command at the start of your code block for output:
options nocenter;
* macros
** intro

*** base

Macros consist of collections of regular SAS program statements, macro
variables, macro language statements, and macro functions contained
within a *%MACRO*and a *%MEND*(closes the macro).
 The *%MACRO* statement includes a *NAME* and the macro *is called using
the macro's name preceded by a %*.
 *example:*
 options mprint;
 *%MACRO* *MYFIRST*;
 PROC PRINT DATA=CLAIMS;
 TITLE1 "TESTING MY FIRST MACRO";
 *%MEND* *MYFIRST*;
 %MYFIRST; /* the macro call */
 to get the log file to output what the macro does assign
 options mprint;
 just before you run the macro

*** Macro variables

*MACRO VARIABLES*
 Macro variables are indicated by preceding a variable name with an
ampersand (*&*).
 Following regular SAS variable naming conventions, we will create a
macro variable called *&year*.
 We will assign a value to &WHEN when we call the macro.
 options mprint;
 %macro *import*(*year=*);
 proc import
datafile="C:UsersekloogDocuments$Doc3.PostDoc3.1.Projetcs3.1.2.MIA_PM_MODELS3.1.2.1.Raw_dataviews
PM&year..txt"
 dbms=dlm out=work.PM*&year* replace;
 delimiter=",";
 getnames=yes;
 guessingrows=500;
 run;
 data pm.PM*&year*(drop = MF_Value Latitude Longitude);
 set work.PM*&year*;
 PM25 = MF_Value;
 Lat_PM = Latitude;
 Long_PM = Longitude;
 format date date9.;
 run;
 *%MEND* ;
 *%import(year=2000);
 %import(year=2001)*;**

*** Tips

a macro followed by a text ( _ or . etc..) needs a double dot (..)

*** 4.SAS macro handbook

[[./sas_files/attach/sas_macro.pdf][Attachment #08 (sas_macro.pdf)]]

** example for yearly macros

%macro *split*(year=); #setup macro, give the name to the macro, inside
the bracket is the name of the macro variables*
*
 data y&year; #the 'y' is added since a filename cant start with a
letter. the & is going to be replaced by the year=XXX
 set Final;
 Y = Year(data);
 if Y = &year;
 run;
 %mend split; #mend means to close the macro
 %split(year=2000);
 %split(year=2001);

** basic macro example

%macro
 regress(fname,out,pol,temp);
 ods output solutionf=sol;
 proc mixed data=&fname;
 class id season wkday;
 model &out = &pol agebase deltaage season wkday &temp /s;
 random intercept /subject=id;
 run;
 data &fname&pol;
 length effect $
 20;
 set sol (keep=effect estimate stderr probt);
 count +
 1;
 if count =
 2;
 run;

 proc append data=&fname&pol base=bigtable force;
 run;
 %mend
 ;

 %regress(gcr,gcr_mean,bcpred_1day,atmp24h);
 %regress(gcr,gcr_mean,bcpred_2day,atmpma2);
 %macro means the macro start
 the & is the start of the line for the stuff that chages
 %mend- means the end of the macro
 %regress(gcr,gcr_mean,bcpred_1day,atmp24h); is for the stuff that
changes

** basic do %i example

#+BEGIN_SRC sas
%macro model1();
	proc datasets library=res1; delete corr1;

	%do i=2003 %to 2012;
		proc mixed data=mod1.stage1_&i method=reml covtest;
			class sitecode date ecoid;
       		model pm25=aod temp--wdsp ah_gm3 ndvi pcturb_1km--Mjrrdden_1km pop_sqkm pbl aod*wdsp aod*pbl/outpred=pred&i;
       	 	random intercept aod  Temp/subject=date;
		     random intercept aod/subject=date(ecoid);
			where ecoid ne .;
		run;
		quit;


	%end;
%mend;
%model1();
#+END_SRC
 
** multi level macros example

 options mprint;
 %macro import(*year*=, *It*=);
 /**** Import 200% dataset *****/
 PROC IMPORT OUT= WORK.mod2_T*&year*
 DATAFILE=
"c:UsersekloogDocuments$Doc3.PostDoc3.1.Projetcs3.1.2.MIA_PM_MODELSV23.1.1.4.Work3.AnalysisAN003_mod2sasout&year..dbf"
 DBMS=DBF REPLACE;
 GETDELETED=NO;
 RUN;
 /*Step s1*/
 /*1)GET THE Overall AOD TEMP SLOPES + INTERCEPT */
 data check_s1_&it;
 set aod.Sol_ran_&it._&year;
 run;
 data check_s1_int(keep = date Ovr_Int);
 set check_s1_&it;
 if reg_id = 1 then delete;
 if reg_id = 2 then delete;
 if reg_id = 3 then delete;
 if reg_id = 4 then delete;
 if reg_id = 5 then delete;
 if reg_id = 6 then delete;
 if reg_id = 7 then delete;
 if zid = 1 then delete;
 if Effect = "AOD" then delete;
 if Effect = "Temp_F_x" then delete;
 Ovr_Int = Estimate;
 run;
 %MEND ;
 %import(*year*=2000, It = s1);
 %import(year=2000, It = s2);
 %import(year=2000, It = s3);
 %import(year=2000, It = s4);
 %import(year=2000, It = s5);
 %import(year=2000, It = s6);
 %import(year=2000, It = s7);
 %import(year=2000, It = s8);
 %import(year=2000, It = s9);
 %import(year=2000, It = s10);
 %import(*year*=2001, It = s1);
 %import(year=2001, It = s2);
 %import(year=2001, It = s3);
 %import(year=2001, It = s4);
 %import(year=2001, It = s5);
 %import(year=2001, It = s6);
 %import(year=2001, It = s7);
 %import(year=2001, It = s8);
 %import(year=2001, It = s9);
 %import(year=2001, It = s10);

** lag macro

*** lag loop with changing id's and moving averages

 %macro makelags(fname,pol);
 proc sort data = &fname; by guid date;run;
 data &pol; set &fname;by guid;
 &pol._l0=&pol;
 %local i;
 %do i=0 %to 365;
 &pol._l%eval(&i+1)=lag1(&pol._l&i);
 if first.guid then &pol._l%eval(&i+1)=.;
 %end;
 &pol.ma1 = mean(&pol._l0,&pol._l1);
 &pol.ma12 = mean(of &pol._l0 - &pol._l11);
 run;
 %mend;
 %makelags(polltemp,pmnew);
 %makelags(polltemp,temp_f);
 where:
 %do i=0 %to 365:
 the red is the range of days needed- here its 365 days including day 0
(lago)
 pmnew/pol-name of outputfile (pmnew)
 polltemp-name of input file
 &pol.ma12 = mean(of &pol._l0 - &pol._l11)
 this calculates the moving averages, for each moving average needed add
a line
 the above example is for the mean (or moving average) from lag 0 (_l0)
to lag 11 (_l11)
 ma12-new name of the variable with the mean of the moving averages
('ma')

*** using a mcaro (not accurate when guid switches)

/*test*/
 data poll2001x;
 set poll2001;
 run;
 proc sort data = Poll2001x; by guid date;run;
 %macro import(lag=);
 data Poll2001x; set Poll2001x;
 if first.guid=0 then lag&lag=lag&lag(pmnew);
 else lag&lag=.;
 run;
 %MEND ;
 %import(lag=1);
 %import(lag=2);
 %import(lag=3);
 %import(lag=4);
 %import(lag=5);
 %import(lag=6);
 %import(lag=7);
 %import(lag=8);
 %import(lag=9);
 %import(lag=10);
 %import(lag=11);
 %import(lag=12);
 %import(lag=13);
 %import(lag=14);
 %import(lag=15);
 %import(lag=16);
 %import(lag=17);
 %import(lag=18);
 %import(lag=19);
 %import(lag=20);
 %import(lag=21);
 %import(lag=22);
 %import(lag=23);
 %import(lag=24);
 %import(lag=25);
 %import(lag=26);
 %import(lag=27);
 %import(lag=28);
 %import(lag=29);
 %import(lag=30);
 %import(lag=31);
 %import(lag=32);
 %import(lag=33);
 %import(lag=34);
 %import(lag=35);
 %import(lag=36);
 %import(lag=37);
 %import(lag=38);
 %import(lag=39);
 %import(lag=40);
 %import(lag=41);
 %import(lag=42);
 %import(lag=43);
 %import(lag=44);
 %import(lag=45);
 %import(lag=46);
 %import(lag=47);
 %import(lag=48);
 %import(lag=49);
 %import(lag=50);
 %import(lag=51);
 %import(lag=52);
 %import(lag=53);
 %import(lag=54);
 %import(lag=55);
 %import(lag=56);
 %import(lag=57);
 %import(lag=58);
 %import(lag=59);
 %import(lag=60);
 %import(lag=61);
 %import(lag=62);
 %import(lag=63);
 %import(lag=64);
 %import(lag=65);
 %import(lag=66);
 %import(lag=67);
 %import(lag=68);
 %import(lag=69);
 %import(lag=70);
 %import(lag=71);
 %import(lag=72);
 %import(lag=73);
 %import(lag=74);
 %import(lag=75);
 %import(lag=76);
 %import(lag=77);
 %import(lag=78);
 %import(lag=79);
 %import(lag=80);
 %import(lag=81);
 %import(lag=82);
 %import(lag=83);
 %import(lag=84);
 %import(lag=85);
 %import(lag=86);
 %import(lag=87);
 %import(lag=88);
 %import(lag=89);
 %import(lag=90);
 %import(lag=91);
 %import(lag=92);
 %import(lag=93);
 %import(lag=94);
 %import(lag=95);
 %import(lag=96);
 %import(lag=97);
 %import(lag=98);
 %import(lag=99);
 %import(lag=100);
 %import(lag=101);
 %import(lag=102);
 %import(lag=103);
 %import(lag=104);
 %import(lag=105);
 %import(lag=106);
 %import(lag=107);
 %import(lag=108);
 %import(lag=109);
 %import(lag=110);
 %import(lag=111);
 %import(lag=112);
 %import(lag=113);
 %import(lag=114);
 %import(lag=115);
 %import(lag=116);
 %import(lag=117);
 %import(lag=118);
 %import(lag=119);
 %import(lag=120);
 %import(lag=121);
 %import(lag=122);
 %import(lag=123);
 %import(lag=124);
 %import(lag=125);
 %import(lag=126);
 %import(lag=127);
 %import(lag=128);
 %import(lag=129);
 %import(lag=130);
 %import(lag=131);
 %import(lag=132);
 %import(lag=133);
 %import(lag=134);
 %import(lag=135);
 %import(lag=136);
 %import(lag=137);
 %import(lag=138);
 %import(lag=139);
 %import(lag=140);
 %import(lag=141);
 %import(lag=142);
 %import(lag=143);
 %import(lag=144);
 %import(lag=145);
 %import(lag=146);
 %import(lag=147);
 %import(lag=148);
 %import(lag=149);
 %import(lag=150);
 %import(lag=151);
 %import(lag=152);
 %import(lag=153);
 %import(lag=154);
 %import(lag=155);
 %import(lag=156);
 %import(lag=157);
 %import(lag=158);
 %import(lag=159);
 %import(lag=160);
 %import(lag=161);
 %import(lag=162);
 %import(lag=163);
 %import(lag=164);
 %import(lag=165);
 %import(lag=166);
 %import(lag=167);
 %import(lag=168);
 %import(lag=169);
 %import(lag=170);
 %import(lag=171);
 %import(lag=172);
 %import(lag=173);
 %import(lag=174);
 %import(lag=175);
 %import(lag=176);
 %import(lag=177);
 %import(lag=178);
 %import(lag=179);
 %import(lag=180);
 %import(lag=181);
 %import(lag=182);
 %import(lag=183);
 %import(lag=184);
 %import(lag=185);
 %import(lag=186);
 %import(lag=187);
 %import(lag=188);
 %import(lag=189);
 %import(lag=190);
 %import(lag=191);
 %import(lag=192);
 %import(lag=193);
 %import(lag=194);
 %import(lag=195);
 %import(lag=196);
 %import(lag=197);
 %import(lag=198);
 %import(lag=199);
 %import(lag=200);
 %import(lag=201);
 %import(lag=202);
 %import(lag=203);
 %import(lag=204);
 %import(lag=205);
 %import(lag=206);
 %import(lag=207);
 %import(lag=208);
 %import(lag=209);
 %import(lag=210);
 %import(lag=211);
 %import(lag=212);
 %import(lag=213);
 %import(lag=214);
 %import(lag=215);
 %import(lag=216);
 %import(lag=217);
 %import(lag=218);
 %import(lag=219);
 %import(lag=220);
 %import(lag=221);
 %import(lag=222);
 %import(lag=223);
 %import(lag=224);
 %import(lag=225);
 %import(lag=226);
 %import(lag=227);
 %import(lag=228);
 %import(lag=229);
 %import(lag=230);
 %import(lag=231);
 %import(lag=232);
 %import(lag=233);
 %import(lag=234);
 %import(lag=235);
 %import(lag=236);
 %import(lag=237);
 %import(lag=238);
 %import(lag=239);
 %import(lag=240);
 %import(lag=241);
 %import(lag=242);
 %import(lag=243);
 %import(lag=244);
 %import(lag=245);
 %import(lag=246);
 %import(lag=247);
 %import(lag=248);
 %import(lag=249);
 %import(lag=250);
 %import(lag=251);
 %import(lag=252);
 %import(lag=253);
 %import(lag=254);
 %import(lag=255);
 %import(lag=256);
 %import(lag=257);
 %import(lag=258);
 %import(lag=259);
 %import(lag=260);
 %import(lag=261);
 %import(lag=262);
 %import(lag=263);
 %import(lag=264);
 %import(lag=265);
 %import(lag=266);
 %import(lag=267);
 %import(lag=268);
 %import(lag=269);
 %import(lag=270);
 %import(lag=271);
 %import(lag=272);
 %import(lag=273);
 %import(lag=274);
 %import(lag=275);
 %import(lag=276);
 %import(lag=277);
 %import(lag=278);
 %import(lag=279);
 %import(lag=280);
 %import(lag=281);
 %import(lag=282);
 %import(lag=283);
 %import(lag=284);
 %import(lag=285);
 %import(lag=286);
 %import(lag=287);
 %import(lag=288);
 %import(lag=289);
 %import(lag=290);
 %import(lag=291);
 %import(lag=292);
 %import(lag=293);
 %import(lag=294);
 %import(lag=295);
 %import(lag=296);
 %import(lag=297);
 %import(lag=298);
 %import(lag=299);
 %import(lag=300);
 %import(lag=301);
 %import(lag=302);
 %import(lag=303);
 %import(lag=304);
 %import(lag=305);
 %import(lag=306);
 %import(lag=307);
 %import(lag=308);
 %import(lag=309);
 %import(lag=310);
 %import(lag=311);
 %import(lag=312);
 %import(lag=313);
 %import(lag=314);
 %import(lag=315);
 %import(lag=316);
 %import(lag=317);
 %import(lag=318);
 %import(lag=319);
 %import(lag=320);
 %import(lag=321);
 %import(lag=322);
 %import(lag=323);
 %import(lag=324);
 %import(lag=325);
 %import(lag=326);
 %import(lag=327);
 %import(lag=328);
 %import(lag=329);
 %import(lag=330);
 %import(lag=331);
 %import(lag=332);
 %import(lag=333);
 %import(lag=334);
 %import(lag=335);
 %import(lag=336);
 %import(lag=337);
 %import(lag=338);
 %import(lag=339);
 %import(lag=340);
 %import(lag=341);
 %import(lag=342);
 %import(lag=343);
 %import(lag=344);
 %import(lag=345);
 %import(lag=346);
 %import(lag=347);
 %import(lag=348);
 %import(lag=349);
 %import(lag=350);
 %import(lag=351);
 %import(lag=352);
 %import(lag=353);
 %import(lag=354);
 %import(lag=355);
 /*%import(lag=356);*/

** macros for 1-X numbers

options mprint;
 *%macro* */picked/*;
 %do i = *1* %to *2*;
 /*** Results for Mod 12 Zinc, Phy With Rice ***/
 proc sort data = faofbs_t; by Item ;run;
 proc sort data = zn.Ran_mod_12_&i; by Item ;run;
 data zn.Results_Mod12_&i;
 merge faofbs_t(in=a) zn.Ran_mod_12_&i(in=b);
 by item;
 if a;
 run;
 proc sort data = faofbs_t; by Item ;run;
 proc sort data = zn.Ran_mod_34_&i; by Item ;run;
 data zn.Results_Mod34_&i;
 merge faofbs_t(in=a) zn.Ran_mod_34_&i(in=b);
 by item;
 if a;
 run;
 proc sort data = faofbs_t; by Item ;run;
 proc sort data = zn.Ran_mod_5_&i; by Item ;run;
 data zn.Results_Mod5_&i;
 merge faofbs_t(in=a) zn.Ran_mod_5_&i(in=b);
 by item;
 if a;
 run;
 proc sort data = faofbs_t; by Item ;run;
 proc sort data = zn.Ran_mod_6_&i; by Item ;run;
 data zn.Results_Mod6_&i;
 merge faofbs_t(in=a) zn.Ran_mod_6_&i(in=b);
 by item;
 if a;
 run;
 %end;
 *%MEND* ;
 %*/picked/*;

* Tips
** portable sas

the place portable sas puts all its user data and settings:
 C:Documents and SettingszeltakApplication DataThinstallSAS 9.1.3

** Adding Comments

to make a code comment
 start with an asterix (*) and end with a semiclon ;
 example:
 * foobar software ;
 Note: When merging data each dataset *MUST*have a common variable with
same ID's and they *MUST* be sorted the same way

** comment syntax

*to start a comment:
*
 /*
 *to end a comment section*
 */
 *example:*
 /* import AOD file with prediction */
 Or type an * at the beginning of a line. Everything between the * and
the ; will be commented
 *Alternatively*:
 highlighting the text that you would like to comment and use the keys:
 Ctrl /
 to comment the line.
 To uncomment a line, highlight and use the
 Ctrl Shift /

** ucla sas course

*** 1.adding data

1.0 SAS statements and procs in this unit
 *infile* Identifies an external raw data file to read
 *input* Lists variable names in the input file
 *datalines*Indicates internal data
 *set* Reads a SAS data set
 *proc contents* Contents of a data set
 *proc print* Prints observations of variables in a data set
 We will start with inputting an Excel file into SAS first through the
SAS Import Wizard. The variable names are on the first line of the Excel
file.
 File
 Import Data
 Choose Excel .xls format (this is actually the default)
 Click on Next
 Click on Browse to select a file: c:sashs0.xls
 The default option is to read variable names from the first
line,
 leave as it is.
 Click on Next
 Enter a name (hs0) for the data set
 Click on Finish
 This method also works for other file formats, such as comma-separated
or tab-delimited files. Now we can look at the data or even modify them
if we want.
 Explorer
 Libraries
 Work
 Double click on hs0
 Edit
 Edit Mode
 Click on data to modify data
 One of more commonly used ASCII data formats is comma-separated-values
(.csv) format. Files of this type can be read in through the Import
Wizard as shown above or through a little bit of programming. We will
now show how to read in a .csv file with a SAS data step. The following
segment is the beginning part of the hs0 file in .csv format. This data
file doesn't have variable names on the first line of data file. Also
notice that the line in bold italics has two consecutive commas near the
end. This means that the value is missing in between. In order to read
in the data correctly, we use option dsd in the infile statement.
 0,70,4,1,1,"general",57,52,41,47,57
 1,121,4,2,1,"vocati",68,59,53,63,61
 0,86,4,3,1,"general",44,33,54,58,31
 0,141,4,3,1,"vocati",63,44,47,53,56
 0,172,4,2,1,"academic",47,52,57,53,61
 0,113,4,2,1,"academic",44,52,51,63,61
 0,50,3,2,1,"general",50,59,42,53,61
 0,11,1,2,1,"academic",34,46,45,39,36
 *0,84,4,2,1,"general",63,57,54,,51*
 0,48,3,2,1,"academic",57,55,52,50,51
 0,75,4,2,1,"vocati",60,46,51,53,61
 0,60,5,2,1,"academic",57,65,51,63,61
 0,95,4,3,1,"academic",73,60,71,61,71
 *NOTE:* the two commas seperated with nothing between means missing
data (marked in red above)
 The following data step will read the data file and name it *temp*. We
will also print out the first ten observations to check that the
inputting was successful.
 data temp;
 infile 'c:sashs0.csv' delimiter=',' dsd;
 input gender id race ses schtyp prgtype $ read write math science
socst ;
 run;
 proc print data = temp (obs=10);
 run;

-  temp is the name of the datafile we will create
-  dsd is needed to adress missing variables etc...
-  $- tells SAS we have a string variable..it is the var that comes
   *BEFORE* the $ sign (prgtype).. "general" in the actuall data
-  print will print the first 10 observations (obs=10)

 it will look like this in SAS
 [[./sas_files/img/Image_38II3Li2ZvyMLXC1VcRZuQ_0001.png]]
 then run the command (use the runing man or F3)
 The other type of commonly used ASCII data format is fixed format. It
always requires a codebook to specify which column corresponds to which
variable. Here is a small example of this type of data with a codebook.
Notice how we make use of the codebook in the input statement below.
 195 094951
 26386161941
 38780081841
 479700 870
 56878163690
 66487182960
 786 069 0
 88194193921
 98979090781
 107868180801
 codebook:
 [[./sas_files/img/image%202.png]]
 data fixed;
 infile "c:sasschdat.fix";
 input id 1-2 a1 3-4 t1 5-6 gender 7 a2 8-9 t2 10-11 tgender 12;
 run;
 proc print data = fixed;
 run;
 Last but not least, sometimes we may want to input data directly from
within SAS and here is what to do.
 data hsb10;
 input id female race ses schtype $ prog
 read write math science socst;
 datalines;
 147 1 1 3 pub 1 47 62 53 53 61
 108 0 1 2 pub 2 34 33 41 36 36
 18 0 3 2 pub 3 50 33 49 44 36
 153 0 1 2 pub 3 39 31 40 39 51
 50 0 2 2 pub 2 50 59 42 53 61
 51 1 2 1 pub 2 42 36 42 31 39
 102 0 1 1 pub 1 52 41 51 53 56
 57 1 1 2 pub 1 71 65 72 66 56
 160 1 1 2 pub 1 55 65 55 50 61
 136 0 1 2 pub 1 65 59 70 63 51
 ;
 run;
 proc print data=hsb10;
 run;
 So far, all the SAS data sets that we have created are temporary.
 That is when we quit SAS, these data sets will be gone. To save a SAS
data file to disk we can do the following.
 data 'c:sasschdat';
 set fixed;
 run;

-  Note that now the data has a full path and "" so that it will be
   saved as a permanent file not as a temp file in the work directory
-  .
    the set tells it what data file to base in on in this case the fixed
   fil

e
 We can directly read permanent SAS data files.
 proc print data='c:sasschdat';
 run;
 Let's use the SAS/Explorer again to see the data sets we have created
in this section. We will use hs0 in our next section.
 Explorer
 Libraries
 Work
 Right click on data sets other than hs0
 Delete

*** 2.exploring data

[[./sas_files/img/Image_9IsfKsu.ETUtv66XuA2gPQ_0001.png]]
 Demonstration and Explanation
 We will begin by settingoptionstonocenterso that the output is left
justified. We will continue to use the SAS dataseths0that was created
in the previous unit. If you don't have the SAS dataset active you can
get it over the Internet from:
 http://www.ats.ucla.edu/stat/sas/notes3/hs0.sas7bdat.
 Before we start our statistical exploration we will look at the data
using theproc contentsandproc printstatements. Note that the
variableprogis a string variable.
 options nocenter;
 proc contents position data='c:sashs0';
 run;

-  **no center is only for asthetic prefrences

 proc print data='c:sashs0' (obs=20);
 run;proc print data='c:sashs0';
  var gender id race ses schtyp prgtype read;
 run;
 this will print all observation with specific variables (var) you want
to see

 The basic descriptive statistics command in SAS isproc means. Below we
get means for all of the variables.
 Theproc meanswith theclassstatement gives descriptive statistics
within groups. Along withproc means, we also show theproc
univariatedisplaying additional descriptive statistics.
 proc means data='c:sashs0';
 run;
 With thevarstatement, we can specify which variables we want to
analyze. Also, then mean median std varoptions allow us to indicate
which statistics we want computed.
 proc means data='c:sashs0' n mean median std var;
 var read math science write;
 run;
 the discriptives we want (n=count, var=varience)
 the variables we want to seeWe use thewherestatement below to look at
just those students with a reading score of 60 or higher.
 proc means data='c:sashs0' n mean median std var;
 where read>=60;
 var read math science write;
 run;
 **only show when reading score is greater than or equel to 60
 With theclassstatement, we get the descriptive statistics broken down
byprgtype.
 proc means data='c:sashs0' n mean median std var;
 class prgtype;
 var read math science write;
 run;
 break down the statistics by prgtype
 [[./sas_files/img/Image_9IsfKsu.ETUtv66XuA2gPQ_0002.png]]
 We can useproc univariateto get detailed descriptive statistics
forwritealong with a histogram with a normal overlay.
 proc univariate plot data='c:sashs0';
 var write;
 histogram / normal;
 run;
 *shows graphics while the / command shows options (in this case show
normal distribution in histogram)
 [[./sas_files/img/image%203.png]]
 We can useproc boxplotto get side-by-side boxplots for the
variablewritebroken down by the levels ofprgtype; however, this
requires that we first sort the data usingproc sort.
 proc sort data='c:sashs0';
 by prgtype;
 run;
 proc boxplot data='c:sashs0';
 plot write*prgtype / boxstyle=schematic boxwidth=10;
 run;
 Belowproc freqis used to get a frequency table forsesandproc
chartshows a bar chart of this distribution.
 proc freq data='c:sashs0';
 table ses;
 run;
 the tables command tells sas which freq table you need..in this case
sesproc chart data='c:sashs0';
 vbar ses / discrete;
 run;
 the vbar shows a verticle bar with an option discrete
 [[./sas_files/img/image%204.png]]
 We useproc freqto get frequencies forwriteand this illustrates why
it can someti*mes be undesir*able to do frequencies for continuous
variables.
 proc freq data='c:sashs0';
 table write;
 run;
 Here we useproc freqto get frequencies
forgender,schtypandprgtype, each table shown separately.
 proc freq data='c:sashs0';
 table gender schtyp prgtype;
 r*un;
 Cross*tabs
 Below we show how to get a crosstab ofprgtypebyses
 proc freq data='c:sashs0';
 table prgtype*ses;
 run;
 the next example shows how to include a chi square test and how to get
the expected frequencies.
 proc freq data='c:sashs0';
 table prgtype*ses / chisq expected;
 run;
 Correlations
 proc corris used to get correlations among variables. By
default,proc corruses pairwise deletion for missing observations. If
you use thenomissoption,proc corruses listwise deletion and omits
all observations with missing data on any of the named variables.
 proc corr data='c:sashs0';
 var write read science;
 run;
 proc corr data='c:sashs0' nomiss;
 var write read science;
 run;
 this will exclude the missing data (nomiss)
 We conclude withproc regshowing a simple regression
predictingwritefromreadalong with a scatterplot and regression line.
 proc reg data='c:sashs0';
 model write=read;
 plot write*read ;
 run;
 [[./sas_files/img/image%205.png]]

*** 3.modifying data

1.0 SAS statements and procs in this unit
 *proc format* Creates formats (aka value labels)
 *label* Creates labels for variables
 *if then* Executes a statement only if the condition is true
 2.0 Demonstration and explanation
 Let's see what the data set looks like.
 proc contents data = "c:sashs0";
 run;
 Let's format one of the variables, schtyp. To add value labels to a
variable, we need to use proc format. Note that the format is not
permanently assigned to the variable. In other words, we need to tell
SAS to use the format whenever we want to see the value labels instead
of the numbers.
 proc format;
 value scl 1 = "public"
 2 = "private";
 run;
 proc freq data = "c:sashs0";
 tables schtyp;
 format schtyp scl.;
 run;
 In this data step, we will label the data set and add a variable label
to the variable schtyp.
 data hs1(label="High School and Beyond, 200 cases");
 set "c:sashs0";
 label schtyp = "The type of school the student attended.";
 run;
 We will now look at the effects of the data step using proc contents.
 proc contents data = hs1;
 run;
 Now we will run a longer data step to do a variety of tasks. Comments
are used to explain the program.
 proc format;
 * create value labels for schtyp ;
 value scl 1 = "public"
 2 = "private";
 * create value labels for grade ;
 value abcdf 0 = "F"
 1 = "D"
 2 = "C"
 3 = "B"
 4 = "A";
 * create value labels for female ;
 value fm 1 = "female"
 0 = "male";
 run;
 *A huge exmaple to organize a dataset
*marked are comments in sas
 green means my comments ..not part of sas code
 * create data file hs1 and label it ;
 data hs1(label="High School and Beyond, 200 cases");
 set "c:sashs0"; * this reads in the sas file c:sashs0 ;
 * the label statement labels the variable schtyp ;
 label schtyp = "The type of school the student attended.";
  * the if-then statements create a new variable, called prog,
 which is numeric variable ;
 if prgtype = "academic" then prog = 1;
 if prgtype = "general" then prog = 2;
 if prgtype = "vocational" then prog = 3;
 * since the variable is string it has to be in "";
 prog- is the new variable it will create
 * the label statement labels the variable prog ;
 label prog = "The type of program in which the student was
enrolled.";
 * create a new variable, called female,
 which is identical to the variable gender ;
 * and then use drop to drop gender ;

 female = gender;
 drop gender;
 drop means it will delete the variable
 * the label statement labels the variable female ;
 label female = "The gender of the student.";
 * the if statement recodes values of 5 in variable race to be missing
(.) ;
 if race = 5 then race = .;
 * create a variable total that is the sum of read + write + socst ;

 total = read + write + socst;
 * create a new variable, called grade, which is identical to total ;
 grade = total;
 * the if-then statements recode grade ;
 if (total < 80) then grade = 0;
 if (80 <= total < 110) then grade = 1;
 if (110 <= total < 140) then grade = 2;
 if (140 <= total < 170) then grade = 3;
 if (total >= 170) then grade = 4;
  * Below we label the variable grade ;
 label grade = "These are the combined grades of read, write and
socst.";
 run;
 Let's check to see that everything worked as planned.
 proc contents data = hs1;
 run;
 proc print data = hs1 (obs = 20);
 format schtyp scl. female fm. grade abcdf.;
 run;
 proc freq data = hs1;
 format schtyp scl. female fm.;
 tables schtyp female;
 run;

*** 4.managing data

[[./sas_files/img/Image_aDrvqkk9t2ksXQEJzwKt5A_0001.png]]
 2.0 Demonstration and Explanation
 Example 2.1 - Honor's Thesis
 Suppose we are undergraduates working on our honors thesis and we wish
to analyze just a subset of the hs1 data file. In fact, we are studying
"good readers" and just want to focus on the students who had a reading
score of 60 and higher. The following shows how we can take the hs1 data
file and make a separate folder called honors and store a copy of our
data which just has the students with reading scores of 60 or higher.
 data "c:sashonorsgoodread";
 set "c:sashs1";
 where (read >=60);
 run;
 proc means data="c:sashonorsgoodread";
 var read;
 run;
 Example 2.1, continued - keeping variables
 Further suppose that our data file had many many variables, say 2000
variables, but we only care about just a handful of them, id female read
and write. We can subset our data file to keep just those variables as
shown below.
 data "c:sashonorshskept";
 set "c:sashonorsgoodread";
 keep id female read write;
 run;
 proc contents data="c:sashonorshskept";
 run;
 Example 2.1, continued - dropping variables
 Instead of wanting to keep just a handful of variables, it is possible
that we might want to get rid of just a handful of variables in our data
file. Below we show how we could get rid of the variables ses and prog.
 data "c:sashonorshsdropped";
 set "c:sashonorsgoodread";
 drop ses prog;
 run;
 proc contents data="c:sashonorshsdropped";
 run;
 Example 2.2 - Master's Thesis
 Now we have moved on to our master's thesis. We have a folder called
masters and we have been given a file with the data for the males
(called hsmale) and a file for the females (called hsfemale). We need to
combine these files together to be able to analyze them, as shown below.
 proc freq data="c:sasmastershsmale";
 tables female;
 run;
 proc freq data="c:sasmastershsfemale";
 tables female;
 run;data "c:sasmastershsmasters";
 set "c:sasmastershsmale" "c:sasmastershsfemale";
 run;
 when sas sees multiple files (green and blue above) it stacks them
 proc freq data="c:sasmastershsmasters";
 tables female;
 run;
 Example 2.3 - Dissertation
 Now we are working on our dissertation and, as with our masters, we
have been given two files. In this case, we have a file that has all of
the demographic information (called hsdem) and a file with the test
scores (called hstest), and we wish to merge these files together. We
show how to do this below.
 proc print data="c:sasdisshsdem"(obs=10);
 run;
 proc print data="c:sasdisshstest"(obs=10);
 run;proc sort data="c:sasdisshsdem" out=dem;
 by id;
 run;
 proc sort data="c:sasdisshstest" out=test;
 by id;
 run;Note: When merging data each dataset*MUST* have a common variable
with same ID's and they*MUS*T be sorted the same way
 data "c:sasdisshsdiss";
 merge dem(in=one) test(in=two);
 fromdem = one;
 fromtest = two;
 by id;
 run;
 proc print data="c:sasdisshsdiss";
 run;
 proc print data="c:sasdisshsdiss";
 var id fromdem fromtest;
 run;
 proc freq data="c:sasdisshsdiss";
 tables fromdem*fromtest ;
 run;

*** 5. analyzing data
* code bits
** Calculate population estimates

#+BEGIN_SRC sas

/*calculate blkfrac and estimated population for intersection of block and grid for all records with blkarea > 0 */
/* calcaream is area of intersection of block with grid polygon in sq meters*/
/*blkarea is area of census block in sq meters*/

data paciorek.eusgrid00blkpopest;
set paciorek.eusgrid00blkpop;
where blkarea>0;
blkfrac = calcaream/ blkarea;
gridblkintpop = blkfrac*totpop;
run;


/* sort by grid id (ET_ID) and calculate sum of area and estimated population*/

proc sort data = paciorek.eusgrid00blkpopest;
by ET_ID;

proc means noprint data=paciorek.eusgrid00blkpopest;
by ET_ID;
var calcaream gridblkintpop;
output out = paciorek.eusgrid00popest sum(calcaream gridblkintpop) = gridaream gridpop;
run;

#+END_SRC

where:

calcaream- area of block
gridblkintpop- areaXpopulation
